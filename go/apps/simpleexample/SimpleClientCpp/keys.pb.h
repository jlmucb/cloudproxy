// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: keys.proto

#ifndef PROTOBUF_keys_2eproto__INCLUDED
#define PROTOBUF_keys_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "attestation.pb.h"
// @@protoc_insertion_point(includes)

namespace tao {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_keys_2eproto();
void protobuf_AssignDesc_keys_2eproto();
void protobuf_ShutdownFile_keys_2eproto();

class CryptoKey;
class CryptoKeyset;
class PBEData;
class ECDSA_SHA_VerifyingKey_v1;
class ECDSA_SHA_SigningKey_v1;
class AES_CTR_HMAC_SHA_CryptingKey_v1;
class HMAC_SHA_DerivingKey_v1;
class CryptoHeader;
class SignaturePDU;
class SignedData;
class EncryptedData;
class KeyDerivationPDU;

enum CryptoKey_CryptoPurpose {
  CryptoKey_CryptoPurpose_VERIFYING = 1,
  CryptoKey_CryptoPurpose_SIGNING = 2,
  CryptoKey_CryptoPurpose_CRYPTING = 3,
  CryptoKey_CryptoPurpose_DERIVING = 4
};
bool CryptoKey_CryptoPurpose_IsValid(int value);
const CryptoKey_CryptoPurpose CryptoKey_CryptoPurpose_CryptoPurpose_MIN = CryptoKey_CryptoPurpose_VERIFYING;
const CryptoKey_CryptoPurpose CryptoKey_CryptoPurpose_CryptoPurpose_MAX = CryptoKey_CryptoPurpose_DERIVING;
const int CryptoKey_CryptoPurpose_CryptoPurpose_ARRAYSIZE = CryptoKey_CryptoPurpose_CryptoPurpose_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoPurpose_descriptor();
inline const ::std::string& CryptoKey_CryptoPurpose_Name(CryptoKey_CryptoPurpose value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoKey_CryptoPurpose_descriptor(), value);
}
inline bool CryptoKey_CryptoPurpose_Parse(
    const ::std::string& name, CryptoKey_CryptoPurpose* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoKey_CryptoPurpose>(
    CryptoKey_CryptoPurpose_descriptor(), name, value);
}
enum CryptoKey_CryptoAlgorithm {
  CryptoKey_CryptoAlgorithm_ECDSA_SHA = 1,
  CryptoKey_CryptoAlgorithm_AES_CTR_HMAC_SHA = 2,
  CryptoKey_CryptoAlgorithm_HMAC_SHA = 3
};
bool CryptoKey_CryptoAlgorithm_IsValid(int value);
const CryptoKey_CryptoAlgorithm CryptoKey_CryptoAlgorithm_CryptoAlgorithm_MIN = CryptoKey_CryptoAlgorithm_ECDSA_SHA;
const CryptoKey_CryptoAlgorithm CryptoKey_CryptoAlgorithm_CryptoAlgorithm_MAX = CryptoKey_CryptoAlgorithm_HMAC_SHA;
const int CryptoKey_CryptoAlgorithm_CryptoAlgorithm_ARRAYSIZE = CryptoKey_CryptoAlgorithm_CryptoAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoAlgorithm_descriptor();
inline const ::std::string& CryptoKey_CryptoAlgorithm_Name(CryptoKey_CryptoAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoKey_CryptoAlgorithm_descriptor(), value);
}
inline bool CryptoKey_CryptoAlgorithm_Parse(
    const ::std::string& name, CryptoKey_CryptoAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoKey_CryptoAlgorithm>(
    CryptoKey_CryptoAlgorithm_descriptor(), name, value);
}
enum CryptoVersion {
  CRYPTO_VERSION_1 = 1
};
bool CryptoVersion_IsValid(int value);
const CryptoVersion CryptoVersion_MIN = CRYPTO_VERSION_1;
const CryptoVersion CryptoVersion_MAX = CRYPTO_VERSION_1;
const int CryptoVersion_ARRAYSIZE = CryptoVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoVersion_descriptor();
inline const ::std::string& CryptoVersion_Name(CryptoVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoVersion_descriptor(), value);
}
inline bool CryptoVersion_Parse(
    const ::std::string& name, CryptoVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoVersion>(
    CryptoVersion_descriptor(), name, value);
}
enum NamedEllipticCurve {
  PRIME256_V1 = 1
};
bool NamedEllipticCurve_IsValid(int value);
const NamedEllipticCurve NamedEllipticCurve_MIN = PRIME256_V1;
const NamedEllipticCurve NamedEllipticCurve_MAX = PRIME256_V1;
const int NamedEllipticCurve_ARRAYSIZE = NamedEllipticCurve_MAX + 1;

const ::google::protobuf::EnumDescriptor* NamedEllipticCurve_descriptor();
inline const ::std::string& NamedEllipticCurve_Name(NamedEllipticCurve value) {
  return ::google::protobuf::internal::NameOfEnum(
    NamedEllipticCurve_descriptor(), value);
}
inline bool NamedEllipticCurve_Parse(
    const ::std::string& name, NamedEllipticCurve* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NamedEllipticCurve>(
    NamedEllipticCurve_descriptor(), name, value);
}
enum CryptoCipherMode {
  CIPHER_MODE_CTR = 1
};
bool CryptoCipherMode_IsValid(int value);
const CryptoCipherMode CryptoCipherMode_MIN = CIPHER_MODE_CTR;
const CryptoCipherMode CryptoCipherMode_MAX = CIPHER_MODE_CTR;
const int CryptoCipherMode_ARRAYSIZE = CryptoCipherMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoCipherMode_descriptor();
inline const ::std::string& CryptoCipherMode_Name(CryptoCipherMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoCipherMode_descriptor(), value);
}
inline bool CryptoCipherMode_Parse(
    const ::std::string& name, CryptoCipherMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoCipherMode>(
    CryptoCipherMode_descriptor(), name, value);
}
enum CryptoDerivingMode {
  DERIVING_MODE_HKDF = 1
};
bool CryptoDerivingMode_IsValid(int value);
const CryptoDerivingMode CryptoDerivingMode_MIN = DERIVING_MODE_HKDF;
const CryptoDerivingMode CryptoDerivingMode_MAX = DERIVING_MODE_HKDF;
const int CryptoDerivingMode_ARRAYSIZE = CryptoDerivingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoDerivingMode_descriptor();
inline const ::std::string& CryptoDerivingMode_Name(CryptoDerivingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoDerivingMode_descriptor(), value);
}
inline bool CryptoDerivingMode_Parse(
    const ::std::string& name, CryptoDerivingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoDerivingMode>(
    CryptoDerivingMode_descriptor(), name, value);
}
// ===================================================================

class CryptoKey : public ::google::protobuf::Message {
 public:
  CryptoKey();
  virtual ~CryptoKey();

  CryptoKey(const CryptoKey& from);

  inline CryptoKey& operator=(const CryptoKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptoKey& default_instance();

  void Swap(CryptoKey* other);

  // implements Message ----------------------------------------------

  CryptoKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CryptoKey& from);
  void MergeFrom(const CryptoKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CryptoKey_CryptoPurpose CryptoPurpose;
  static const CryptoPurpose VERIFYING = CryptoKey_CryptoPurpose_VERIFYING;
  static const CryptoPurpose SIGNING = CryptoKey_CryptoPurpose_SIGNING;
  static const CryptoPurpose CRYPTING = CryptoKey_CryptoPurpose_CRYPTING;
  static const CryptoPurpose DERIVING = CryptoKey_CryptoPurpose_DERIVING;
  static inline bool CryptoPurpose_IsValid(int value) {
    return CryptoKey_CryptoPurpose_IsValid(value);
  }
  static const CryptoPurpose CryptoPurpose_MIN =
    CryptoKey_CryptoPurpose_CryptoPurpose_MIN;
  static const CryptoPurpose CryptoPurpose_MAX =
    CryptoKey_CryptoPurpose_CryptoPurpose_MAX;
  static const int CryptoPurpose_ARRAYSIZE =
    CryptoKey_CryptoPurpose_CryptoPurpose_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CryptoPurpose_descriptor() {
    return CryptoKey_CryptoPurpose_descriptor();
  }
  static inline const ::std::string& CryptoPurpose_Name(CryptoPurpose value) {
    return CryptoKey_CryptoPurpose_Name(value);
  }
  static inline bool CryptoPurpose_Parse(const ::std::string& name,
      CryptoPurpose* value) {
    return CryptoKey_CryptoPurpose_Parse(name, value);
  }

  typedef CryptoKey_CryptoAlgorithm CryptoAlgorithm;
  static const CryptoAlgorithm ECDSA_SHA = CryptoKey_CryptoAlgorithm_ECDSA_SHA;
  static const CryptoAlgorithm AES_CTR_HMAC_SHA = CryptoKey_CryptoAlgorithm_AES_CTR_HMAC_SHA;
  static const CryptoAlgorithm HMAC_SHA = CryptoKey_CryptoAlgorithm_HMAC_SHA;
  static inline bool CryptoAlgorithm_IsValid(int value) {
    return CryptoKey_CryptoAlgorithm_IsValid(value);
  }
  static const CryptoAlgorithm CryptoAlgorithm_MIN =
    CryptoKey_CryptoAlgorithm_CryptoAlgorithm_MIN;
  static const CryptoAlgorithm CryptoAlgorithm_MAX =
    CryptoKey_CryptoAlgorithm_CryptoAlgorithm_MAX;
  static const int CryptoAlgorithm_ARRAYSIZE =
    CryptoKey_CryptoAlgorithm_CryptoAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CryptoAlgorithm_descriptor() {
    return CryptoKey_CryptoAlgorithm_descriptor();
  }
  static inline const ::std::string& CryptoAlgorithm_Name(CryptoAlgorithm value) {
    return CryptoKey_CryptoAlgorithm_Name(value);
  }
  static inline bool CryptoAlgorithm_Parse(const ::std::string& name,
      CryptoAlgorithm* value) {
    return CryptoKey_CryptoAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tao.CryptoVersion version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::tao::CryptoVersion version() const;
  inline void set_version(::tao::CryptoVersion value);

  // required .tao.CryptoKey.CryptoPurpose purpose = 2;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 2;
  inline ::tao::CryptoKey_CryptoPurpose purpose() const;
  inline void set_purpose(::tao::CryptoKey_CryptoPurpose value);

  // required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 3;
  inline ::tao::CryptoKey_CryptoAlgorithm algorithm() const;
  inline void set_algorithm(::tao::CryptoKey_CryptoAlgorithm value);

  // required bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:tao.CryptoKey)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_algorithm();
  inline void clear_has_algorithm();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int version_;
  int purpose_;
  ::std::string* key_;
  int algorithm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static CryptoKey* default_instance_;
};
// -------------------------------------------------------------------

class CryptoKeyset : public ::google::protobuf::Message {
 public:
  CryptoKeyset();
  virtual ~CryptoKeyset();

  CryptoKeyset(const CryptoKeyset& from);

  inline CryptoKeyset& operator=(const CryptoKeyset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptoKeyset& default_instance();

  void Swap(CryptoKeyset* other);

  // implements Message ----------------------------------------------

  CryptoKeyset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CryptoKeyset& from);
  void MergeFrom(const CryptoKeyset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tao.CryptoKey keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::tao::CryptoKey& keys(int index) const;
  inline ::tao::CryptoKey* mutable_keys(int index);
  inline ::tao::CryptoKey* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::tao::CryptoKey >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::tao::CryptoKey >*
      mutable_keys();

  // optional .tao.Attestation delegation = 2;
  inline bool has_delegation() const;
  inline void clear_delegation();
  static const int kDelegationFieldNumber = 2;
  inline const ::tao::Attestation& delegation() const;
  inline ::tao::Attestation* mutable_delegation();
  inline ::tao::Attestation* release_delegation();
  inline void set_allocated_delegation(::tao::Attestation* delegation);

  // @@protoc_insertion_point(class_scope:tao.CryptoKeyset)
 private:
  inline void set_has_delegation();
  inline void clear_has_delegation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tao::CryptoKey > keys_;
  ::tao::Attestation* delegation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static CryptoKeyset* default_instance_;
};
// -------------------------------------------------------------------

class PBEData : public ::google::protobuf::Message {
 public:
  PBEData();
  virtual ~PBEData();

  PBEData(const PBEData& from);

  inline PBEData& operator=(const PBEData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBEData& default_instance();

  void Swap(PBEData* other);

  // implements Message ----------------------------------------------

  PBEData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBEData& from);
  void MergeFrom(const PBEData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoVersion version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::tao::CryptoVersion version() const;
  inline void set_version(::tao::CryptoVersion value);

  // required string cipher = 2;
  inline bool has_cipher() const;
  inline void clear_cipher();
  static const int kCipherFieldNumber = 2;
  inline const ::std::string& cipher() const;
  inline void set_cipher(const ::std::string& value);
  inline void set_cipher(const char* value);
  inline void set_cipher(const char* value, size_t size);
  inline ::std::string* mutable_cipher();
  inline ::std::string* release_cipher();
  inline void set_allocated_cipher(::std::string* cipher);

  // required string hmac = 3;
  inline bool has_hmac() const;
  inline void clear_hmac();
  static const int kHmacFieldNumber = 3;
  inline const ::std::string& hmac() const;
  inline void set_hmac(const ::std::string& value);
  inline void set_hmac(const char* value);
  inline void set_hmac(const char* value, size_t size);
  inline ::std::string* mutable_hmac();
  inline ::std::string* release_hmac();
  inline void set_allocated_hmac(::std::string* hmac);

  // required int32 iterations = 4;
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 4;
  inline ::google::protobuf::int32 iterations() const;
  inline void set_iterations(::google::protobuf::int32 value);

  // required bytes iv = 5;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 5;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // required bytes ciphertext = 6;
  inline bool has_ciphertext() const;
  inline void clear_ciphertext();
  static const int kCiphertextFieldNumber = 6;
  inline const ::std::string& ciphertext() const;
  inline void set_ciphertext(const ::std::string& value);
  inline void set_ciphertext(const char* value);
  inline void set_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_ciphertext();
  inline ::std::string* release_ciphertext();
  inline void set_allocated_ciphertext(::std::string* ciphertext);

  // required bytes salt = 7;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 7;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // @@protoc_insertion_point(class_scope:tao.PBEData)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cipher();
  inline void clear_has_cipher();
  inline void set_has_hmac();
  inline void clear_has_hmac();
  inline void set_has_iterations();
  inline void clear_has_iterations();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_ciphertext();
  inline void clear_has_ciphertext();
  inline void set_has_salt();
  inline void clear_has_salt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cipher_;
  int version_;
  ::google::protobuf::int32 iterations_;
  ::std::string* hmac_;
  ::std::string* iv_;
  ::std::string* ciphertext_;
  ::std::string* salt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static PBEData* default_instance_;
};
// -------------------------------------------------------------------

class ECDSA_SHA_VerifyingKey_v1 : public ::google::protobuf::Message {
 public:
  ECDSA_SHA_VerifyingKey_v1();
  virtual ~ECDSA_SHA_VerifyingKey_v1();

  ECDSA_SHA_VerifyingKey_v1(const ECDSA_SHA_VerifyingKey_v1& from);

  inline ECDSA_SHA_VerifyingKey_v1& operator=(const ECDSA_SHA_VerifyingKey_v1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECDSA_SHA_VerifyingKey_v1& default_instance();

  void Swap(ECDSA_SHA_VerifyingKey_v1* other);

  // implements Message ----------------------------------------------

  ECDSA_SHA_VerifyingKey_v1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ECDSA_SHA_VerifyingKey_v1& from);
  void MergeFrom(const ECDSA_SHA_VerifyingKey_v1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.NamedEllipticCurve curve = 1;
  inline bool has_curve() const;
  inline void clear_curve();
  static const int kCurveFieldNumber = 1;
  inline ::tao::NamedEllipticCurve curve() const;
  inline void set_curve(::tao::NamedEllipticCurve value);

  // required bytes ec_public = 2;
  inline bool has_ec_public() const;
  inline void clear_ec_public();
  static const int kEcPublicFieldNumber = 2;
  inline const ::std::string& ec_public() const;
  inline void set_ec_public(const ::std::string& value);
  inline void set_ec_public(const char* value);
  inline void set_ec_public(const void* value, size_t size);
  inline ::std::string* mutable_ec_public();
  inline ::std::string* release_ec_public();
  inline void set_allocated_ec_public(::std::string* ec_public);

  // @@protoc_insertion_point(class_scope:tao.ECDSA_SHA_VerifyingKey_v1)
 private:
  inline void set_has_curve();
  inline void clear_has_curve();
  inline void set_has_ec_public();
  inline void clear_has_ec_public();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ec_public_;
  int curve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static ECDSA_SHA_VerifyingKey_v1* default_instance_;
};
// -------------------------------------------------------------------

class ECDSA_SHA_SigningKey_v1 : public ::google::protobuf::Message {
 public:
  ECDSA_SHA_SigningKey_v1();
  virtual ~ECDSA_SHA_SigningKey_v1();

  ECDSA_SHA_SigningKey_v1(const ECDSA_SHA_SigningKey_v1& from);

  inline ECDSA_SHA_SigningKey_v1& operator=(const ECDSA_SHA_SigningKey_v1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECDSA_SHA_SigningKey_v1& default_instance();

  void Swap(ECDSA_SHA_SigningKey_v1* other);

  // implements Message ----------------------------------------------

  ECDSA_SHA_SigningKey_v1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ECDSA_SHA_SigningKey_v1& from);
  void MergeFrom(const ECDSA_SHA_SigningKey_v1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.NamedEllipticCurve curve = 1;
  inline bool has_curve() const;
  inline void clear_curve();
  static const int kCurveFieldNumber = 1;
  inline ::tao::NamedEllipticCurve curve() const;
  inline void set_curve(::tao::NamedEllipticCurve value);

  // required bytes ec_private = 2;
  inline bool has_ec_private() const;
  inline void clear_ec_private();
  static const int kEcPrivateFieldNumber = 2;
  inline const ::std::string& ec_private() const;
  inline void set_ec_private(const ::std::string& value);
  inline void set_ec_private(const char* value);
  inline void set_ec_private(const void* value, size_t size);
  inline ::std::string* mutable_ec_private();
  inline ::std::string* release_ec_private();
  inline void set_allocated_ec_private(::std::string* ec_private);

  // required bytes ec_public = 3;
  inline bool has_ec_public() const;
  inline void clear_ec_public();
  static const int kEcPublicFieldNumber = 3;
  inline const ::std::string& ec_public() const;
  inline void set_ec_public(const ::std::string& value);
  inline void set_ec_public(const char* value);
  inline void set_ec_public(const void* value, size_t size);
  inline ::std::string* mutable_ec_public();
  inline ::std::string* release_ec_public();
  inline void set_allocated_ec_public(::std::string* ec_public);

  // @@protoc_insertion_point(class_scope:tao.ECDSA_SHA_SigningKey_v1)
 private:
  inline void set_has_curve();
  inline void clear_has_curve();
  inline void set_has_ec_private();
  inline void clear_has_ec_private();
  inline void set_has_ec_public();
  inline void clear_has_ec_public();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ec_private_;
  ::std::string* ec_public_;
  int curve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static ECDSA_SHA_SigningKey_v1* default_instance_;
};
// -------------------------------------------------------------------

class AES_CTR_HMAC_SHA_CryptingKey_v1 : public ::google::protobuf::Message {
 public:
  AES_CTR_HMAC_SHA_CryptingKey_v1();
  virtual ~AES_CTR_HMAC_SHA_CryptingKey_v1();

  AES_CTR_HMAC_SHA_CryptingKey_v1(const AES_CTR_HMAC_SHA_CryptingKey_v1& from);

  inline AES_CTR_HMAC_SHA_CryptingKey_v1& operator=(const AES_CTR_HMAC_SHA_CryptingKey_v1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AES_CTR_HMAC_SHA_CryptingKey_v1& default_instance();

  void Swap(AES_CTR_HMAC_SHA_CryptingKey_v1* other);

  // implements Message ----------------------------------------------

  AES_CTR_HMAC_SHA_CryptingKey_v1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AES_CTR_HMAC_SHA_CryptingKey_v1& from);
  void MergeFrom(const AES_CTR_HMAC_SHA_CryptingKey_v1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoCipherMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::tao::CryptoCipherMode mode() const;
  inline void set_mode(::tao::CryptoCipherMode value);

  // required bytes aes_private = 2;
  inline bool has_aes_private() const;
  inline void clear_aes_private();
  static const int kAesPrivateFieldNumber = 2;
  inline const ::std::string& aes_private() const;
  inline void set_aes_private(const ::std::string& value);
  inline void set_aes_private(const char* value);
  inline void set_aes_private(const void* value, size_t size);
  inline ::std::string* mutable_aes_private();
  inline ::std::string* release_aes_private();
  inline void set_allocated_aes_private(::std::string* aes_private);

  // required bytes hmac_private = 3;
  inline bool has_hmac_private() const;
  inline void clear_hmac_private();
  static const int kHmacPrivateFieldNumber = 3;
  inline const ::std::string& hmac_private() const;
  inline void set_hmac_private(const ::std::string& value);
  inline void set_hmac_private(const char* value);
  inline void set_hmac_private(const void* value, size_t size);
  inline ::std::string* mutable_hmac_private();
  inline ::std::string* release_hmac_private();
  inline void set_allocated_hmac_private(::std::string* hmac_private);

  // @@protoc_insertion_point(class_scope:tao.AES_CTR_HMAC_SHA_CryptingKey_v1)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_aes_private();
  inline void clear_has_aes_private();
  inline void set_has_hmac_private();
  inline void clear_has_hmac_private();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* aes_private_;
  ::std::string* hmac_private_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static AES_CTR_HMAC_SHA_CryptingKey_v1* default_instance_;
};
// -------------------------------------------------------------------

class HMAC_SHA_DerivingKey_v1 : public ::google::protobuf::Message {
 public:
  HMAC_SHA_DerivingKey_v1();
  virtual ~HMAC_SHA_DerivingKey_v1();

  HMAC_SHA_DerivingKey_v1(const HMAC_SHA_DerivingKey_v1& from);

  inline HMAC_SHA_DerivingKey_v1& operator=(const HMAC_SHA_DerivingKey_v1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HMAC_SHA_DerivingKey_v1& default_instance();

  void Swap(HMAC_SHA_DerivingKey_v1* other);

  // implements Message ----------------------------------------------

  HMAC_SHA_DerivingKey_v1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HMAC_SHA_DerivingKey_v1& from);
  void MergeFrom(const HMAC_SHA_DerivingKey_v1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoDerivingMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::tao::CryptoDerivingMode mode() const;
  inline void set_mode(::tao::CryptoDerivingMode value);

  // required bytes hmac_private = 2;
  inline bool has_hmac_private() const;
  inline void clear_hmac_private();
  static const int kHmacPrivateFieldNumber = 2;
  inline const ::std::string& hmac_private() const;
  inline void set_hmac_private(const ::std::string& value);
  inline void set_hmac_private(const char* value);
  inline void set_hmac_private(const void* value, size_t size);
  inline ::std::string* mutable_hmac_private();
  inline ::std::string* release_hmac_private();
  inline void set_allocated_hmac_private(::std::string* hmac_private);

  // @@protoc_insertion_point(class_scope:tao.HMAC_SHA_DerivingKey_v1)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_hmac_private();
  inline void clear_has_hmac_private();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hmac_private_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static HMAC_SHA_DerivingKey_v1* default_instance_;
};
// -------------------------------------------------------------------

class CryptoHeader : public ::google::protobuf::Message {
 public:
  CryptoHeader();
  virtual ~CryptoHeader();

  CryptoHeader(const CryptoHeader& from);

  inline CryptoHeader& operator=(const CryptoHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptoHeader& default_instance();

  void Swap(CryptoHeader* other);

  // implements Message ----------------------------------------------

  CryptoHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CryptoHeader& from);
  void MergeFrom(const CryptoHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoVersion version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::tao::CryptoVersion version() const;
  inline void set_version(::tao::CryptoVersion value);

  // required bytes key_hint = 2;
  inline bool has_key_hint() const;
  inline void clear_key_hint();
  static const int kKeyHintFieldNumber = 2;
  inline const ::std::string& key_hint() const;
  inline void set_key_hint(const ::std::string& value);
  inline void set_key_hint(const char* value);
  inline void set_key_hint(const void* value, size_t size);
  inline ::std::string* mutable_key_hint();
  inline ::std::string* release_key_hint();
  inline void set_allocated_key_hint(::std::string* key_hint);

  // @@protoc_insertion_point(class_scope:tao.CryptoHeader)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_key_hint();
  inline void clear_has_key_hint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_hint_;
  int version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static CryptoHeader* default_instance_;
};
// -------------------------------------------------------------------

class SignaturePDU : public ::google::protobuf::Message {
 public:
  SignaturePDU();
  virtual ~SignaturePDU();

  SignaturePDU(const SignaturePDU& from);

  inline SignaturePDU& operator=(const SignaturePDU& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignaturePDU& default_instance();

  void Swap(SignaturePDU* other);

  // implements Message ----------------------------------------------

  SignaturePDU* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignaturePDU& from);
  void MergeFrom(const SignaturePDU& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::tao::CryptoHeader& header() const;
  inline ::tao::CryptoHeader* mutable_header();
  inline ::tao::CryptoHeader* release_header();
  inline void set_allocated_header(::tao::CryptoHeader* header);

  // required string context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:tao.SignaturePDU)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tao::CryptoHeader* header_;
  ::std::string* context_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static SignaturePDU* default_instance_;
};
// -------------------------------------------------------------------

class SignedData : public ::google::protobuf::Message {
 public:
  SignedData();
  virtual ~SignedData();

  SignedData(const SignedData& from);

  inline SignedData& operator=(const SignedData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedData& default_instance();

  void Swap(SignedData* other);

  // implements Message ----------------------------------------------

  SignedData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedData& from);
  void MergeFrom(const SignedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::tao::CryptoHeader& header() const;
  inline ::tao::CryptoHeader* mutable_header();
  inline ::tao::CryptoHeader* release_header();
  inline void set_allocated_header(::tao::CryptoHeader* header);

  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:tao.SignedData)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tao::CryptoHeader* header_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static SignedData* default_instance_;
};
// -------------------------------------------------------------------

class EncryptedData : public ::google::protobuf::Message {
 public:
  EncryptedData();
  virtual ~EncryptedData();

  EncryptedData(const EncryptedData& from);

  inline EncryptedData& operator=(const EncryptedData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptedData& default_instance();

  void Swap(EncryptedData* other);

  // implements Message ----------------------------------------------

  EncryptedData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptedData& from);
  void MergeFrom(const EncryptedData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tao.CryptoHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::tao::CryptoHeader& header() const;
  inline ::tao::CryptoHeader* mutable_header();
  inline ::tao::CryptoHeader* release_header();
  inline void set_allocated_header(::tao::CryptoHeader* header);

  // required bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // required bytes ciphertext = 3;
  inline bool has_ciphertext() const;
  inline void clear_ciphertext();
  static const int kCiphertextFieldNumber = 3;
  inline const ::std::string& ciphertext() const;
  inline void set_ciphertext(const ::std::string& value);
  inline void set_ciphertext(const char* value);
  inline void set_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_ciphertext();
  inline ::std::string* release_ciphertext();
  inline void set_allocated_ciphertext(::std::string* ciphertext);

  // optional bytes mac = 4;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 4;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const void* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // @@protoc_insertion_point(class_scope:tao.EncryptedData)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_ciphertext();
  inline void clear_has_ciphertext();
  inline void set_has_mac();
  inline void clear_has_mac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tao::CryptoHeader* header_;
  ::std::string* iv_;
  ::std::string* ciphertext_;
  ::std::string* mac_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static EncryptedData* default_instance_;
};
// -------------------------------------------------------------------

class KeyDerivationPDU : public ::google::protobuf::Message {
 public:
  KeyDerivationPDU();
  virtual ~KeyDerivationPDU();

  KeyDerivationPDU(const KeyDerivationPDU& from);

  inline KeyDerivationPDU& operator=(const KeyDerivationPDU& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyDerivationPDU& default_instance();

  void Swap(KeyDerivationPDU* other);

  // implements Message ----------------------------------------------

  KeyDerivationPDU* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyDerivationPDU& from);
  void MergeFrom(const KeyDerivationPDU& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes previous_hash = 1;
  inline bool has_previous_hash() const;
  inline void clear_previous_hash();
  static const int kPreviousHashFieldNumber = 1;
  inline const ::std::string& previous_hash() const;
  inline void set_previous_hash(const ::std::string& value);
  inline void set_previous_hash(const char* value);
  inline void set_previous_hash(const void* value, size_t size);
  inline ::std::string* mutable_previous_hash();
  inline ::std::string* release_previous_hash();
  inline void set_allocated_previous_hash(::std::string* previous_hash);

  // required fixed32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // required string context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required fixed32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tao.KeyDerivationPDU)
 private:
  inline void set_has_previous_hash();
  inline void clear_has_previous_hash();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* previous_hash_;
  ::std::string* context_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_keys_2eproto();
  friend void protobuf_AssignDesc_keys_2eproto();
  friend void protobuf_ShutdownFile_keys_2eproto();

  void InitAsDefaultInstance();
  static KeyDerivationPDU* default_instance_;
};
// ===================================================================


// ===================================================================

// CryptoKey

// required .tao.CryptoVersion version = 1;
inline bool CryptoKey::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptoKey::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptoKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptoKey::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::tao::CryptoVersion CryptoKey::version() const {
  return static_cast< ::tao::CryptoVersion >(version_);
}
inline void CryptoKey::set_version(::tao::CryptoVersion value) {
  assert(::tao::CryptoVersion_IsValid(value));
  set_has_version();
  version_ = value;
}

// required .tao.CryptoKey.CryptoPurpose purpose = 2;
inline bool CryptoKey::has_purpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptoKey::set_has_purpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptoKey::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptoKey::clear_purpose() {
  purpose_ = 1;
  clear_has_purpose();
}
inline ::tao::CryptoKey_CryptoPurpose CryptoKey::purpose() const {
  return static_cast< ::tao::CryptoKey_CryptoPurpose >(purpose_);
}
inline void CryptoKey::set_purpose(::tao::CryptoKey_CryptoPurpose value) {
  assert(::tao::CryptoKey_CryptoPurpose_IsValid(value));
  set_has_purpose();
  purpose_ = value;
}

// required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
inline bool CryptoKey::has_algorithm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CryptoKey::set_has_algorithm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CryptoKey::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CryptoKey::clear_algorithm() {
  algorithm_ = 1;
  clear_has_algorithm();
}
inline ::tao::CryptoKey_CryptoAlgorithm CryptoKey::algorithm() const {
  return static_cast< ::tao::CryptoKey_CryptoAlgorithm >(algorithm_);
}
inline void CryptoKey::set_algorithm(::tao::CryptoKey_CryptoAlgorithm value) {
  assert(::tao::CryptoKey_CryptoAlgorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
}

// required bytes key = 4;
inline bool CryptoKey::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CryptoKey::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CryptoKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CryptoKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CryptoKey::key() const {
  return *key_;
}
inline void CryptoKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CryptoKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CryptoKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptoKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CryptoKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CryptoKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CryptoKeyset

// repeated .tao.CryptoKey keys = 1;
inline int CryptoKeyset::keys_size() const {
  return keys_.size();
}
inline void CryptoKeyset::clear_keys() {
  keys_.Clear();
}
inline const ::tao::CryptoKey& CryptoKeyset::keys(int index) const {
  return keys_.Get(index);
}
inline ::tao::CryptoKey* CryptoKeyset::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::tao::CryptoKey* CryptoKeyset::add_keys() {
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tao::CryptoKey >&
CryptoKeyset::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::tao::CryptoKey >*
CryptoKeyset::mutable_keys() {
  return &keys_;
}

// optional .tao.Attestation delegation = 2;
inline bool CryptoKeyset::has_delegation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptoKeyset::set_has_delegation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptoKeyset::clear_has_delegation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptoKeyset::clear_delegation() {
  if (delegation_ != NULL) delegation_->::tao::Attestation::Clear();
  clear_has_delegation();
}
inline const ::tao::Attestation& CryptoKeyset::delegation() const {
  return delegation_ != NULL ? *delegation_ : *default_instance_->delegation_;
}
inline ::tao::Attestation* CryptoKeyset::mutable_delegation() {
  set_has_delegation();
  if (delegation_ == NULL) delegation_ = new ::tao::Attestation;
  return delegation_;
}
inline ::tao::Attestation* CryptoKeyset::release_delegation() {
  clear_has_delegation();
  ::tao::Attestation* temp = delegation_;
  delegation_ = NULL;
  return temp;
}
inline void CryptoKeyset::set_allocated_delegation(::tao::Attestation* delegation) {
  delete delegation_;
  delegation_ = delegation;
  if (delegation) {
    set_has_delegation();
  } else {
    clear_has_delegation();
  }
}

// -------------------------------------------------------------------

// PBEData

// required .tao.CryptoVersion version = 1;
inline bool PBEData::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBEData::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBEData::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBEData::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::tao::CryptoVersion PBEData::version() const {
  return static_cast< ::tao::CryptoVersion >(version_);
}
inline void PBEData::set_version(::tao::CryptoVersion value) {
  assert(::tao::CryptoVersion_IsValid(value));
  set_has_version();
  version_ = value;
}

// required string cipher = 2;
inline bool PBEData::has_cipher() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBEData::set_has_cipher() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBEData::clear_has_cipher() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBEData::clear_cipher() {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    cipher_->clear();
  }
  clear_has_cipher();
}
inline const ::std::string& PBEData::cipher() const {
  return *cipher_;
}
inline void PBEData::set_cipher(const ::std::string& value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void PBEData::set_cipher(const char* value) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void PBEData::set_cipher(const char* value, size_t size) {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBEData::mutable_cipher() {
  set_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    cipher_ = new ::std::string;
  }
  return cipher_;
}
inline ::std::string* PBEData::release_cipher() {
  clear_has_cipher();
  if (cipher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipher_;
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBEData::set_allocated_cipher(::std::string* cipher) {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    delete cipher_;
  }
  if (cipher) {
    set_has_cipher();
    cipher_ = cipher;
  } else {
    clear_has_cipher();
    cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hmac = 3;
inline bool PBEData::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBEData::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBEData::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBEData::clear_hmac() {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    hmac_->clear();
  }
  clear_has_hmac();
}
inline const ::std::string& PBEData::hmac() const {
  return *hmac_;
}
inline void PBEData::set_hmac(const ::std::string& value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void PBEData::set_hmac(const char* value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void PBEData::set_hmac(const char* value, size_t size) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBEData::mutable_hmac() {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  return hmac_;
}
inline ::std::string* PBEData::release_hmac() {
  clear_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_;
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBEData::set_allocated_hmac(::std::string* hmac) {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (hmac) {
    set_has_hmac();
    hmac_ = hmac;
  } else {
    clear_has_hmac();
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 iterations = 4;
inline bool PBEData::has_iterations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PBEData::set_has_iterations() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PBEData::clear_has_iterations() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PBEData::clear_iterations() {
  iterations_ = 0;
  clear_has_iterations();
}
inline ::google::protobuf::int32 PBEData::iterations() const {
  return iterations_;
}
inline void PBEData::set_iterations(::google::protobuf::int32 value) {
  set_has_iterations();
  iterations_ = value;
}

// required bytes iv = 5;
inline bool PBEData::has_iv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PBEData::set_has_iv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PBEData::clear_has_iv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PBEData::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& PBEData::iv() const {
  return *iv_;
}
inline void PBEData::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void PBEData::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void PBEData::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBEData::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* PBEData::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBEData::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes ciphertext = 6;
inline bool PBEData::has_ciphertext() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PBEData::set_has_ciphertext() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PBEData::clear_has_ciphertext() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PBEData::clear_ciphertext() {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    ciphertext_->clear();
  }
  clear_has_ciphertext();
}
inline const ::std::string& PBEData::ciphertext() const {
  return *ciphertext_;
}
inline void PBEData::set_ciphertext(const ::std::string& value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void PBEData::set_ciphertext(const char* value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void PBEData::set_ciphertext(const void* value, size_t size) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBEData::mutable_ciphertext() {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  return ciphertext_;
}
inline ::std::string* PBEData::release_ciphertext() {
  clear_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ciphertext_;
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBEData::set_allocated_ciphertext(::std::string* ciphertext) {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (ciphertext) {
    set_has_ciphertext();
    ciphertext_ = ciphertext;
  } else {
    clear_has_ciphertext();
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes salt = 7;
inline bool PBEData::has_salt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PBEData::set_has_salt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PBEData::clear_has_salt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PBEData::clear_salt() {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& PBEData::salt() const {
  return *salt_;
}
inline void PBEData::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void PBEData::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void PBEData::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBEData::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  return salt_;
}
inline ::std::string* PBEData::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBEData::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ECDSA_SHA_VerifyingKey_v1

// required .tao.NamedEllipticCurve curve = 1;
inline bool ECDSA_SHA_VerifyingKey_v1::has_curve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECDSA_SHA_VerifyingKey_v1::set_has_curve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECDSA_SHA_VerifyingKey_v1::clear_has_curve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECDSA_SHA_VerifyingKey_v1::clear_curve() {
  curve_ = 1;
  clear_has_curve();
}
inline ::tao::NamedEllipticCurve ECDSA_SHA_VerifyingKey_v1::curve() const {
  return static_cast< ::tao::NamedEllipticCurve >(curve_);
}
inline void ECDSA_SHA_VerifyingKey_v1::set_curve(::tao::NamedEllipticCurve value) {
  assert(::tao::NamedEllipticCurve_IsValid(value));
  set_has_curve();
  curve_ = value;
}

// required bytes ec_public = 2;
inline bool ECDSA_SHA_VerifyingKey_v1::has_ec_public() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ECDSA_SHA_VerifyingKey_v1::set_has_ec_public() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ECDSA_SHA_VerifyingKey_v1::clear_has_ec_public() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ECDSA_SHA_VerifyingKey_v1::clear_ec_public() {
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    ec_public_->clear();
  }
  clear_has_ec_public();
}
inline const ::std::string& ECDSA_SHA_VerifyingKey_v1::ec_public() const {
  return *ec_public_;
}
inline void ECDSA_SHA_VerifyingKey_v1::set_ec_public(const ::std::string& value) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(value);
}
inline void ECDSA_SHA_VerifyingKey_v1::set_ec_public(const char* value) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(value);
}
inline void ECDSA_SHA_VerifyingKey_v1::set_ec_public(const void* value, size_t size) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ECDSA_SHA_VerifyingKey_v1::mutable_ec_public() {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  return ec_public_;
}
inline ::std::string* ECDSA_SHA_VerifyingKey_v1::release_ec_public() {
  clear_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ec_public_;
    ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ECDSA_SHA_VerifyingKey_v1::set_allocated_ec_public(::std::string* ec_public) {
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_public_;
  }
  if (ec_public) {
    set_has_ec_public();
    ec_public_ = ec_public;
  } else {
    clear_has_ec_public();
    ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ECDSA_SHA_SigningKey_v1

// required .tao.NamedEllipticCurve curve = 1;
inline bool ECDSA_SHA_SigningKey_v1::has_curve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECDSA_SHA_SigningKey_v1::set_has_curve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_has_curve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_curve() {
  curve_ = 1;
  clear_has_curve();
}
inline ::tao::NamedEllipticCurve ECDSA_SHA_SigningKey_v1::curve() const {
  return static_cast< ::tao::NamedEllipticCurve >(curve_);
}
inline void ECDSA_SHA_SigningKey_v1::set_curve(::tao::NamedEllipticCurve value) {
  assert(::tao::NamedEllipticCurve_IsValid(value));
  set_has_curve();
  curve_ = value;
}

// required bytes ec_private = 2;
inline bool ECDSA_SHA_SigningKey_v1::has_ec_private() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ECDSA_SHA_SigningKey_v1::set_has_ec_private() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_has_ec_private() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_ec_private() {
  if (ec_private_ != &::google::protobuf::internal::kEmptyString) {
    ec_private_->clear();
  }
  clear_has_ec_private();
}
inline const ::std::string& ECDSA_SHA_SigningKey_v1::ec_private() const {
  return *ec_private_;
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_private(const ::std::string& value) {
  set_has_ec_private();
  if (ec_private_ == &::google::protobuf::internal::kEmptyString) {
    ec_private_ = new ::std::string;
  }
  ec_private_->assign(value);
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_private(const char* value) {
  set_has_ec_private();
  if (ec_private_ == &::google::protobuf::internal::kEmptyString) {
    ec_private_ = new ::std::string;
  }
  ec_private_->assign(value);
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_private(const void* value, size_t size) {
  set_has_ec_private();
  if (ec_private_ == &::google::protobuf::internal::kEmptyString) {
    ec_private_ = new ::std::string;
  }
  ec_private_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ECDSA_SHA_SigningKey_v1::mutable_ec_private() {
  set_has_ec_private();
  if (ec_private_ == &::google::protobuf::internal::kEmptyString) {
    ec_private_ = new ::std::string;
  }
  return ec_private_;
}
inline ::std::string* ECDSA_SHA_SigningKey_v1::release_ec_private() {
  clear_has_ec_private();
  if (ec_private_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ec_private_;
    ec_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ECDSA_SHA_SigningKey_v1::set_allocated_ec_private(::std::string* ec_private) {
  if (ec_private_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_private_;
  }
  if (ec_private) {
    set_has_ec_private();
    ec_private_ = ec_private;
  } else {
    clear_has_ec_private();
    ec_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes ec_public = 3;
inline bool ECDSA_SHA_SigningKey_v1::has_ec_public() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ECDSA_SHA_SigningKey_v1::set_has_ec_public() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_has_ec_public() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ECDSA_SHA_SigningKey_v1::clear_ec_public() {
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    ec_public_->clear();
  }
  clear_has_ec_public();
}
inline const ::std::string& ECDSA_SHA_SigningKey_v1::ec_public() const {
  return *ec_public_;
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_public(const ::std::string& value) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(value);
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_public(const char* value) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(value);
}
inline void ECDSA_SHA_SigningKey_v1::set_ec_public(const void* value, size_t size) {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  ec_public_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ECDSA_SHA_SigningKey_v1::mutable_ec_public() {
  set_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    ec_public_ = new ::std::string;
  }
  return ec_public_;
}
inline ::std::string* ECDSA_SHA_SigningKey_v1::release_ec_public() {
  clear_has_ec_public();
  if (ec_public_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ec_public_;
    ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ECDSA_SHA_SigningKey_v1::set_allocated_ec_public(::std::string* ec_public) {
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_public_;
  }
  if (ec_public) {
    set_has_ec_public();
    ec_public_ = ec_public;
  } else {
    clear_has_ec_public();
    ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AES_CTR_HMAC_SHA_CryptingKey_v1

// required .tao.CryptoCipherMode mode = 1;
inline bool AES_CTR_HMAC_SHA_CryptingKey_v1::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::tao::CryptoCipherMode AES_CTR_HMAC_SHA_CryptingKey_v1::mode() const {
  return static_cast< ::tao::CryptoCipherMode >(mode_);
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_mode(::tao::CryptoCipherMode value) {
  assert(::tao::CryptoCipherMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// required bytes aes_private = 2;
inline bool AES_CTR_HMAC_SHA_CryptingKey_v1::has_aes_private() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_has_aes_private() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_has_aes_private() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_aes_private() {
  if (aes_private_ != &::google::protobuf::internal::kEmptyString) {
    aes_private_->clear();
  }
  clear_has_aes_private();
}
inline const ::std::string& AES_CTR_HMAC_SHA_CryptingKey_v1::aes_private() const {
  return *aes_private_;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_aes_private(const ::std::string& value) {
  set_has_aes_private();
  if (aes_private_ == &::google::protobuf::internal::kEmptyString) {
    aes_private_ = new ::std::string;
  }
  aes_private_->assign(value);
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_aes_private(const char* value) {
  set_has_aes_private();
  if (aes_private_ == &::google::protobuf::internal::kEmptyString) {
    aes_private_ = new ::std::string;
  }
  aes_private_->assign(value);
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_aes_private(const void* value, size_t size) {
  set_has_aes_private();
  if (aes_private_ == &::google::protobuf::internal::kEmptyString) {
    aes_private_ = new ::std::string;
  }
  aes_private_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AES_CTR_HMAC_SHA_CryptingKey_v1::mutable_aes_private() {
  set_has_aes_private();
  if (aes_private_ == &::google::protobuf::internal::kEmptyString) {
    aes_private_ = new ::std::string;
  }
  return aes_private_;
}
inline ::std::string* AES_CTR_HMAC_SHA_CryptingKey_v1::release_aes_private() {
  clear_has_aes_private();
  if (aes_private_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aes_private_;
    aes_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_allocated_aes_private(::std::string* aes_private) {
  if (aes_private_ != &::google::protobuf::internal::kEmptyString) {
    delete aes_private_;
  }
  if (aes_private) {
    set_has_aes_private();
    aes_private_ = aes_private;
  } else {
    clear_has_aes_private();
    aes_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes hmac_private = 3;
inline bool AES_CTR_HMAC_SHA_CryptingKey_v1::has_hmac_private() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_has_hmac_private() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_has_hmac_private() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::clear_hmac_private() {
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    hmac_private_->clear();
  }
  clear_has_hmac_private();
}
inline const ::std::string& AES_CTR_HMAC_SHA_CryptingKey_v1::hmac_private() const {
  return *hmac_private_;
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_hmac_private(const ::std::string& value) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(value);
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_hmac_private(const char* value) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(value);
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_hmac_private(const void* value, size_t size) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AES_CTR_HMAC_SHA_CryptingKey_v1::mutable_hmac_private() {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  return hmac_private_;
}
inline ::std::string* AES_CTR_HMAC_SHA_CryptingKey_v1::release_hmac_private() {
  clear_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_private_;
    hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AES_CTR_HMAC_SHA_CryptingKey_v1::set_allocated_hmac_private(::std::string* hmac_private) {
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_private_;
  }
  if (hmac_private) {
    set_has_hmac_private();
    hmac_private_ = hmac_private;
  } else {
    clear_has_hmac_private();
    hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HMAC_SHA_DerivingKey_v1

// required .tao.CryptoDerivingMode mode = 1;
inline bool HMAC_SHA_DerivingKey_v1::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HMAC_SHA_DerivingKey_v1::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HMAC_SHA_DerivingKey_v1::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HMAC_SHA_DerivingKey_v1::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::tao::CryptoDerivingMode HMAC_SHA_DerivingKey_v1::mode() const {
  return static_cast< ::tao::CryptoDerivingMode >(mode_);
}
inline void HMAC_SHA_DerivingKey_v1::set_mode(::tao::CryptoDerivingMode value) {
  assert(::tao::CryptoDerivingMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// required bytes hmac_private = 2;
inline bool HMAC_SHA_DerivingKey_v1::has_hmac_private() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HMAC_SHA_DerivingKey_v1::set_has_hmac_private() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HMAC_SHA_DerivingKey_v1::clear_has_hmac_private() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HMAC_SHA_DerivingKey_v1::clear_hmac_private() {
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    hmac_private_->clear();
  }
  clear_has_hmac_private();
}
inline const ::std::string& HMAC_SHA_DerivingKey_v1::hmac_private() const {
  return *hmac_private_;
}
inline void HMAC_SHA_DerivingKey_v1::set_hmac_private(const ::std::string& value) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(value);
}
inline void HMAC_SHA_DerivingKey_v1::set_hmac_private(const char* value) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(value);
}
inline void HMAC_SHA_DerivingKey_v1::set_hmac_private(const void* value, size_t size) {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  hmac_private_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HMAC_SHA_DerivingKey_v1::mutable_hmac_private() {
  set_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    hmac_private_ = new ::std::string;
  }
  return hmac_private_;
}
inline ::std::string* HMAC_SHA_DerivingKey_v1::release_hmac_private() {
  clear_has_hmac_private();
  if (hmac_private_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_private_;
    hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HMAC_SHA_DerivingKey_v1::set_allocated_hmac_private(::std::string* hmac_private) {
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_private_;
  }
  if (hmac_private) {
    set_has_hmac_private();
    hmac_private_ = hmac_private;
  } else {
    clear_has_hmac_private();
    hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CryptoHeader

// required .tao.CryptoVersion version = 1;
inline bool CryptoHeader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptoHeader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptoHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptoHeader::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::tao::CryptoVersion CryptoHeader::version() const {
  return static_cast< ::tao::CryptoVersion >(version_);
}
inline void CryptoHeader::set_version(::tao::CryptoVersion value) {
  assert(::tao::CryptoVersion_IsValid(value));
  set_has_version();
  version_ = value;
}

// required bytes key_hint = 2;
inline bool CryptoHeader::has_key_hint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptoHeader::set_has_key_hint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptoHeader::clear_has_key_hint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptoHeader::clear_key_hint() {
  if (key_hint_ != &::google::protobuf::internal::kEmptyString) {
    key_hint_->clear();
  }
  clear_has_key_hint();
}
inline const ::std::string& CryptoHeader::key_hint() const {
  return *key_hint_;
}
inline void CryptoHeader::set_key_hint(const ::std::string& value) {
  set_has_key_hint();
  if (key_hint_ == &::google::protobuf::internal::kEmptyString) {
    key_hint_ = new ::std::string;
  }
  key_hint_->assign(value);
}
inline void CryptoHeader::set_key_hint(const char* value) {
  set_has_key_hint();
  if (key_hint_ == &::google::protobuf::internal::kEmptyString) {
    key_hint_ = new ::std::string;
  }
  key_hint_->assign(value);
}
inline void CryptoHeader::set_key_hint(const void* value, size_t size) {
  set_has_key_hint();
  if (key_hint_ == &::google::protobuf::internal::kEmptyString) {
    key_hint_ = new ::std::string;
  }
  key_hint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptoHeader::mutable_key_hint() {
  set_has_key_hint();
  if (key_hint_ == &::google::protobuf::internal::kEmptyString) {
    key_hint_ = new ::std::string;
  }
  return key_hint_;
}
inline ::std::string* CryptoHeader::release_key_hint() {
  clear_has_key_hint();
  if (key_hint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_hint_;
    key_hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CryptoHeader::set_allocated_key_hint(::std::string* key_hint) {
  if (key_hint_ != &::google::protobuf::internal::kEmptyString) {
    delete key_hint_;
  }
  if (key_hint) {
    set_has_key_hint();
    key_hint_ = key_hint;
  } else {
    clear_has_key_hint();
    key_hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignaturePDU

// required .tao.CryptoHeader header = 1;
inline bool SignaturePDU::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignaturePDU::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignaturePDU::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignaturePDU::clear_header() {
  if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
  clear_has_header();
}
inline const ::tao::CryptoHeader& SignaturePDU::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::tao::CryptoHeader* SignaturePDU::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::tao::CryptoHeader;
  return header_;
}
inline ::tao::CryptoHeader* SignaturePDU::release_header() {
  clear_has_header();
  ::tao::CryptoHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SignaturePDU::set_allocated_header(::tao::CryptoHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required string context = 2;
inline bool SignaturePDU::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignaturePDU::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignaturePDU::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignaturePDU::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& SignaturePDU::context() const {
  return *context_;
}
inline void SignaturePDU::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void SignaturePDU::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void SignaturePDU::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignaturePDU::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* SignaturePDU::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignaturePDU::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 3;
inline bool SignaturePDU::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignaturePDU::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignaturePDU::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignaturePDU::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& SignaturePDU::data() const {
  return *data_;
}
inline void SignaturePDU::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SignaturePDU::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void SignaturePDU::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignaturePDU::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* SignaturePDU::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignaturePDU::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedData

// required .tao.CryptoHeader header = 1;
inline bool SignedData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedData::clear_header() {
  if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
  clear_has_header();
}
inline const ::tao::CryptoHeader& SignedData::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::tao::CryptoHeader* SignedData::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::tao::CryptoHeader;
  return header_;
}
inline ::tao::CryptoHeader* SignedData::release_header() {
  clear_has_header();
  ::tao::CryptoHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SignedData::set_allocated_header(::tao::CryptoHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required bytes signature = 2;
inline bool SignedData::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedData::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedData::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedData::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedData::signature() const {
  return *signature_;
}
inline void SignedData::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedData::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedData::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedData::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedData::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedData::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EncryptedData

// required .tao.CryptoHeader header = 1;
inline bool EncryptedData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptedData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptedData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptedData::clear_header() {
  if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
  clear_has_header();
}
inline const ::tao::CryptoHeader& EncryptedData::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::tao::CryptoHeader* EncryptedData::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::tao::CryptoHeader;
  return header_;
}
inline ::tao::CryptoHeader* EncryptedData::release_header() {
  clear_has_header();
  ::tao::CryptoHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EncryptedData::set_allocated_header(::tao::CryptoHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required bytes iv = 2;
inline bool EncryptedData::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptedData::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptedData::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptedData::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& EncryptedData::iv() const {
  return *iv_;
}
inline void EncryptedData::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptedData::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptedData::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedData::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* EncryptedData::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedData::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes ciphertext = 3;
inline bool EncryptedData::has_ciphertext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptedData::set_has_ciphertext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptedData::clear_has_ciphertext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptedData::clear_ciphertext() {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    ciphertext_->clear();
  }
  clear_has_ciphertext();
}
inline const ::std::string& EncryptedData::ciphertext() const {
  return *ciphertext_;
}
inline void EncryptedData::set_ciphertext(const ::std::string& value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void EncryptedData::set_ciphertext(const char* value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void EncryptedData::set_ciphertext(const void* value, size_t size) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedData::mutable_ciphertext() {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  return ciphertext_;
}
inline ::std::string* EncryptedData::release_ciphertext() {
  clear_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ciphertext_;
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedData::set_allocated_ciphertext(::std::string* ciphertext) {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (ciphertext) {
    set_has_ciphertext();
    ciphertext_ = ciphertext;
  } else {
    clear_has_ciphertext();
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mac = 4;
inline bool EncryptedData::has_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncryptedData::set_has_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncryptedData::clear_has_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncryptedData::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& EncryptedData::mac() const {
  return *mac_;
}
inline void EncryptedData::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void EncryptedData::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void EncryptedData::set_mac(const void* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedData::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* EncryptedData::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptedData::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KeyDerivationPDU

// required bytes previous_hash = 1;
inline bool KeyDerivationPDU::has_previous_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyDerivationPDU::set_has_previous_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyDerivationPDU::clear_has_previous_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyDerivationPDU::clear_previous_hash() {
  if (previous_hash_ != &::google::protobuf::internal::kEmptyString) {
    previous_hash_->clear();
  }
  clear_has_previous_hash();
}
inline const ::std::string& KeyDerivationPDU::previous_hash() const {
  return *previous_hash_;
}
inline void KeyDerivationPDU::set_previous_hash(const ::std::string& value) {
  set_has_previous_hash();
  if (previous_hash_ == &::google::protobuf::internal::kEmptyString) {
    previous_hash_ = new ::std::string;
  }
  previous_hash_->assign(value);
}
inline void KeyDerivationPDU::set_previous_hash(const char* value) {
  set_has_previous_hash();
  if (previous_hash_ == &::google::protobuf::internal::kEmptyString) {
    previous_hash_ = new ::std::string;
  }
  previous_hash_->assign(value);
}
inline void KeyDerivationPDU::set_previous_hash(const void* value, size_t size) {
  set_has_previous_hash();
  if (previous_hash_ == &::google::protobuf::internal::kEmptyString) {
    previous_hash_ = new ::std::string;
  }
  previous_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyDerivationPDU::mutable_previous_hash() {
  set_has_previous_hash();
  if (previous_hash_ == &::google::protobuf::internal::kEmptyString) {
    previous_hash_ = new ::std::string;
  }
  return previous_hash_;
}
inline ::std::string* KeyDerivationPDU::release_previous_hash() {
  clear_has_previous_hash();
  if (previous_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previous_hash_;
    previous_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyDerivationPDU::set_allocated_previous_hash(::std::string* previous_hash) {
  if (previous_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete previous_hash_;
  }
  if (previous_hash) {
    set_has_previous_hash();
    previous_hash_ = previous_hash;
  } else {
    clear_has_previous_hash();
    previous_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 size = 2;
inline bool KeyDerivationPDU::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyDerivationPDU::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyDerivationPDU::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyDerivationPDU::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 KeyDerivationPDU::size() const {
  return size_;
}
inline void KeyDerivationPDU::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// required string context = 3;
inline bool KeyDerivationPDU::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyDerivationPDU::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyDerivationPDU::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyDerivationPDU::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& KeyDerivationPDU::context() const {
  return *context_;
}
inline void KeyDerivationPDU::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void KeyDerivationPDU::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void KeyDerivationPDU::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyDerivationPDU::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* KeyDerivationPDU::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyDerivationPDU::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 index = 4;
inline bool KeyDerivationPDU::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyDerivationPDU::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyDerivationPDU::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyDerivationPDU::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 KeyDerivationPDU::index() const {
  return index_;
}
inline void KeyDerivationPDU::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tao

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::CryptoKey_CryptoPurpose>() {
  return ::tao::CryptoKey_CryptoPurpose_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::CryptoKey_CryptoAlgorithm>() {
  return ::tao::CryptoKey_CryptoAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::CryptoVersion>() {
  return ::tao::CryptoVersion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::NamedEllipticCurve>() {
  return ::tao::NamedEllipticCurve_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::CryptoCipherMode>() {
  return ::tao::CryptoCipherMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tao::CryptoDerivingMode>() {
  return ::tao::CryptoDerivingMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_keys_2eproto__INCLUDED
