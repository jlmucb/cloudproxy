// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: keys.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "keys.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace tao {

namespace {

const ::google::protobuf::Descriptor* CryptoKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptoKey_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoPurpose_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoAlgorithm_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CryptoKeyset_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptoKeyset_reflection_ = NULL;
const ::google::protobuf::Descriptor* PBEData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PBEData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ECDSA_SHA_VerifyingKey_v1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ECDSA_SHA_VerifyingKey_v1_reflection_ = NULL;
const ::google::protobuf::Descriptor* ECDSA_SHA_SigningKey_v1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ECDSA_SHA_SigningKey_v1_reflection_ = NULL;
const ::google::protobuf::Descriptor* AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AES_CTR_HMAC_SHA_CryptingKey_v1_reflection_ = NULL;
const ::google::protobuf::Descriptor* HMAC_SHA_DerivingKey_v1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HMAC_SHA_DerivingKey_v1_reflection_ = NULL;
const ::google::protobuf::Descriptor* CryptoHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptoHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignaturePDU_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignaturePDU_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* EncryptedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EncryptedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyDerivationPDU_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyDerivationPDU_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoVersion_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* NamedEllipticCurve_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoCipherMode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoDerivingMode_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_keys_2eproto() {
  protobuf_AddDesc_keys_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "keys.proto");
  GOOGLE_CHECK(file != NULL);
  CryptoKey_descriptor_ = file->message_type(0);
  static const int CryptoKey_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, purpose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, key_),
  };
  CryptoKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptoKey_descriptor_,
      CryptoKey::default_instance_,
      CryptoKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptoKey));
  CryptoKey_CryptoPurpose_descriptor_ = CryptoKey_descriptor_->enum_type(0);
  CryptoKey_CryptoAlgorithm_descriptor_ = CryptoKey_descriptor_->enum_type(1);
  CryptoKeyset_descriptor_ = file->message_type(1);
  static const int CryptoKeyset_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKeyset, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKeyset, delegation_),
  };
  CryptoKeyset_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptoKeyset_descriptor_,
      CryptoKeyset::default_instance_,
      CryptoKeyset_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKeyset, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoKeyset, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptoKeyset));
  PBEData_descriptor_ = file->message_type(2);
  static const int PBEData_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, cipher_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, hmac_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, ciphertext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, salt_),
  };
  PBEData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PBEData_descriptor_,
      PBEData::default_instance_,
      PBEData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PBEData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PBEData));
  ECDSA_SHA_VerifyingKey_v1_descriptor_ = file->message_type(3);
  static const int ECDSA_SHA_VerifyingKey_v1_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_VerifyingKey_v1, curve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_VerifyingKey_v1, ec_public_),
  };
  ECDSA_SHA_VerifyingKey_v1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ECDSA_SHA_VerifyingKey_v1_descriptor_,
      ECDSA_SHA_VerifyingKey_v1::default_instance_,
      ECDSA_SHA_VerifyingKey_v1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_VerifyingKey_v1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_VerifyingKey_v1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ECDSA_SHA_VerifyingKey_v1));
  ECDSA_SHA_SigningKey_v1_descriptor_ = file->message_type(4);
  static const int ECDSA_SHA_SigningKey_v1_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_SigningKey_v1, curve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_SigningKey_v1, ec_private_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_SigningKey_v1, ec_public_),
  };
  ECDSA_SHA_SigningKey_v1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ECDSA_SHA_SigningKey_v1_descriptor_,
      ECDSA_SHA_SigningKey_v1::default_instance_,
      ECDSA_SHA_SigningKey_v1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_SigningKey_v1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDSA_SHA_SigningKey_v1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ECDSA_SHA_SigningKey_v1));
  AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_ = file->message_type(5);
  static const int AES_CTR_HMAC_SHA_CryptingKey_v1_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AES_CTR_HMAC_SHA_CryptingKey_v1, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AES_CTR_HMAC_SHA_CryptingKey_v1, aes_private_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AES_CTR_HMAC_SHA_CryptingKey_v1, hmac_private_),
  };
  AES_CTR_HMAC_SHA_CryptingKey_v1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_,
      AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance_,
      AES_CTR_HMAC_SHA_CryptingKey_v1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AES_CTR_HMAC_SHA_CryptingKey_v1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AES_CTR_HMAC_SHA_CryptingKey_v1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AES_CTR_HMAC_SHA_CryptingKey_v1));
  HMAC_SHA_DerivingKey_v1_descriptor_ = file->message_type(6);
  static const int HMAC_SHA_DerivingKey_v1_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMAC_SHA_DerivingKey_v1, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMAC_SHA_DerivingKey_v1, hmac_private_),
  };
  HMAC_SHA_DerivingKey_v1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HMAC_SHA_DerivingKey_v1_descriptor_,
      HMAC_SHA_DerivingKey_v1::default_instance_,
      HMAC_SHA_DerivingKey_v1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMAC_SHA_DerivingKey_v1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMAC_SHA_DerivingKey_v1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HMAC_SHA_DerivingKey_v1));
  CryptoHeader_descriptor_ = file->message_type(7);
  static const int CryptoHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoHeader, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoHeader, key_hint_),
  };
  CryptoHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptoHeader_descriptor_,
      CryptoHeader::default_instance_,
      CryptoHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptoHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptoHeader));
  SignaturePDU_descriptor_ = file->message_type(8);
  static const int SignaturePDU_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignaturePDU, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignaturePDU, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignaturePDU, data_),
  };
  SignaturePDU_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignaturePDU_descriptor_,
      SignaturePDU::default_instance_,
      SignaturePDU_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignaturePDU, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignaturePDU, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignaturePDU));
  SignedData_descriptor_ = file->message_type(9);
  static const int SignedData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedData, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedData, signature_),
  };
  SignedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedData_descriptor_,
      SignedData::default_instance_,
      SignedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedData));
  EncryptedData_descriptor_ = file->message_type(10);
  static const int EncryptedData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, ciphertext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, mac_),
  };
  EncryptedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EncryptedData_descriptor_,
      EncryptedData::default_instance_,
      EncryptedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EncryptedData));
  KeyDerivationPDU_descriptor_ = file->message_type(11);
  static const int KeyDerivationPDU_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, previous_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, index_),
  };
  KeyDerivationPDU_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyDerivationPDU_descriptor_,
      KeyDerivationPDU::default_instance_,
      KeyDerivationPDU_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyDerivationPDU, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyDerivationPDU));
  CryptoVersion_descriptor_ = file->enum_type(0);
  NamedEllipticCurve_descriptor_ = file->enum_type(1);
  CryptoCipherMode_descriptor_ = file->enum_type(2);
  CryptoDerivingMode_descriptor_ = file->enum_type(3);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_keys_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptoKey_descriptor_, &CryptoKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptoKeyset_descriptor_, &CryptoKeyset::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PBEData_descriptor_, &PBEData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ECDSA_SHA_VerifyingKey_v1_descriptor_, &ECDSA_SHA_VerifyingKey_v1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ECDSA_SHA_SigningKey_v1_descriptor_, &ECDSA_SHA_SigningKey_v1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_, &AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HMAC_SHA_DerivingKey_v1_descriptor_, &HMAC_SHA_DerivingKey_v1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptoHeader_descriptor_, &CryptoHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignaturePDU_descriptor_, &SignaturePDU::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedData_descriptor_, &SignedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EncryptedData_descriptor_, &EncryptedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyDerivationPDU_descriptor_, &KeyDerivationPDU::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_keys_2eproto() {
  delete CryptoKey::default_instance_;
  delete CryptoKey_reflection_;
  delete CryptoKeyset::default_instance_;
  delete CryptoKeyset_reflection_;
  delete PBEData::default_instance_;
  delete PBEData_reflection_;
  delete ECDSA_SHA_VerifyingKey_v1::default_instance_;
  delete ECDSA_SHA_VerifyingKey_v1_reflection_;
  delete ECDSA_SHA_SigningKey_v1::default_instance_;
  delete ECDSA_SHA_SigningKey_v1_reflection_;
  delete AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance_;
  delete AES_CTR_HMAC_SHA_CryptingKey_v1_reflection_;
  delete HMAC_SHA_DerivingKey_v1::default_instance_;
  delete HMAC_SHA_DerivingKey_v1_reflection_;
  delete CryptoHeader::default_instance_;
  delete CryptoHeader_reflection_;
  delete SignaturePDU::default_instance_;
  delete SignaturePDU_reflection_;
  delete SignedData::default_instance_;
  delete SignedData_reflection_;
  delete EncryptedData::default_instance_;
  delete EncryptedData_reflection_;
  delete KeyDerivationPDU::default_instance_;
  delete KeyDerivationPDU_reflection_;
}

void protobuf_AddDesc_keys_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::tao::protobuf_AddDesc_attestation_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nkeys.proto\022\003tao\032\021attestation.proto\"\256\002\n"
    "\tCryptoKey\022#\n\007version\030\001 \002(\0162\022.tao.Crypto"
    "Version\022-\n\007purpose\030\002 \002(\0162\034.tao.CryptoKey"
    ".CryptoPurpose\0221\n\talgorithm\030\003 \002(\0162\036.tao."
    "CryptoKey.CryptoAlgorithm\022\013\n\003key\030\004 \002(\014\"G"
    "\n\rCryptoPurpose\022\r\n\tVERIFYING\020\001\022\013\n\007SIGNIN"
    "G\020\002\022\014\n\010CRYPTING\020\003\022\014\n\010DERIVING\020\004\"D\n\017Crypt"
    "oAlgorithm\022\r\n\tECDSA_SHA\020\001\022\024\n\020AES_CTR_HMA"
    "C_SHA\020\002\022\014\n\010HMAC_SHA\020\003\"R\n\014CryptoKeyset\022\034\n"
    "\004keys\030\001 \003(\0132\016.tao.CryptoKey\022$\n\ndelegatio"
    "n\030\002 \001(\0132\020.tao.Attestation\"\216\001\n\007PBEData\022#\n"
    "\007version\030\001 \002(\0162\022.tao.CryptoVersion\022\016\n\006ci"
    "pher\030\002 \002(\t\022\014\n\004hmac\030\003 \002(\t\022\022\n\niterations\030\004"
    " \002(\005\022\n\n\002iv\030\005 \002(\014\022\022\n\nciphertext\030\006 \002(\014\022\014\n\004"
    "salt\030\007 \002(\014\"V\n\031ECDSA_SHA_VerifyingKey_v1\022"
    "&\n\005curve\030\001 \002(\0162\027.tao.NamedEllipticCurve\022"
    "\021\n\tec_public\030\002 \002(\014\"h\n\027ECDSA_SHA_SigningK"
    "ey_v1\022&\n\005curve\030\001 \002(\0162\027.tao.NamedElliptic"
    "Curve\022\022\n\nec_private\030\002 \002(\014\022\021\n\tec_public\030\003"
    " \002(\014\"q\n\037AES_CTR_HMAC_SHA_CryptingKey_v1\022"
    "#\n\004mode\030\001 \002(\0162\025.tao.CryptoCipherMode\022\023\n\013"
    "aes_private\030\002 \002(\014\022\024\n\014hmac_private\030\003 \002(\014\""
    "V\n\027HMAC_SHA_DerivingKey_v1\022%\n\004mode\030\001 \002(\016"
    "2\027.tao.CryptoDerivingMode\022\024\n\014hmac_privat"
    "e\030\002 \002(\014\"E\n\014CryptoHeader\022#\n\007version\030\001 \002(\016"
    "2\022.tao.CryptoVersion\022\020\n\010key_hint\030\002 \002(\014\"P"
    "\n\014SignaturePDU\022!\n\006header\030\001 \002(\0132\021.tao.Cry"
    "ptoHeader\022\017\n\007context\030\002 \002(\t\022\014\n\004data\030\003 \002(\014"
    "\"B\n\nSignedData\022!\n\006header\030\001 \002(\0132\021.tao.Cry"
    "ptoHeader\022\021\n\tsignature\030\002 \002(\014\"_\n\rEncrypte"
    "dData\022!\n\006header\030\001 \002(\0132\021.tao.CryptoHeader"
    "\022\n\n\002iv\030\002 \002(\014\022\022\n\nciphertext\030\003 \002(\014\022\013\n\003mac\030"
    "\004 \001(\014\"W\n\020KeyDerivationPDU\022\025\n\rprevious_ha"
    "sh\030\001 \002(\014\022\014\n\004size\030\002 \002(\007\022\017\n\007context\030\003 \002(\t\022"
    "\r\n\005index\030\004 \002(\007*%\n\rCryptoVersion\022\024\n\020CRYPT"
    "O_VERSION_1\020\001*%\n\022NamedEllipticCurve\022\017\n\013P"
    "RIME256_V1\020\001*\'\n\020CryptoCipherMode\022\023\n\017CIPH"
    "ER_MODE_CTR\020\001*,\n\022CryptoDerivingMode\022\026\n\022D"
    "ERIVING_MODE_HKDF\020\001", 1539);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "keys.proto", &protobuf_RegisterTypes);
  CryptoKey::default_instance_ = new CryptoKey();
  CryptoKeyset::default_instance_ = new CryptoKeyset();
  PBEData::default_instance_ = new PBEData();
  ECDSA_SHA_VerifyingKey_v1::default_instance_ = new ECDSA_SHA_VerifyingKey_v1();
  ECDSA_SHA_SigningKey_v1::default_instance_ = new ECDSA_SHA_SigningKey_v1();
  AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance_ = new AES_CTR_HMAC_SHA_CryptingKey_v1();
  HMAC_SHA_DerivingKey_v1::default_instance_ = new HMAC_SHA_DerivingKey_v1();
  CryptoHeader::default_instance_ = new CryptoHeader();
  SignaturePDU::default_instance_ = new SignaturePDU();
  SignedData::default_instance_ = new SignedData();
  EncryptedData::default_instance_ = new EncryptedData();
  KeyDerivationPDU::default_instance_ = new KeyDerivationPDU();
  CryptoKey::default_instance_->InitAsDefaultInstance();
  CryptoKeyset::default_instance_->InitAsDefaultInstance();
  PBEData::default_instance_->InitAsDefaultInstance();
  ECDSA_SHA_VerifyingKey_v1::default_instance_->InitAsDefaultInstance();
  ECDSA_SHA_SigningKey_v1::default_instance_->InitAsDefaultInstance();
  AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance_->InitAsDefaultInstance();
  HMAC_SHA_DerivingKey_v1::default_instance_->InitAsDefaultInstance();
  CryptoHeader::default_instance_->InitAsDefaultInstance();
  SignaturePDU::default_instance_->InitAsDefaultInstance();
  SignedData::default_instance_->InitAsDefaultInstance();
  EncryptedData::default_instance_->InitAsDefaultInstance();
  KeyDerivationPDU::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_keys_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_keys_2eproto {
  StaticDescriptorInitializer_keys_2eproto() {
    protobuf_AddDesc_keys_2eproto();
  }
} static_descriptor_initializer_keys_2eproto_;
const ::google::protobuf::EnumDescriptor* CryptoVersion_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoVersion_descriptor_;
}
bool CryptoVersion_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NamedEllipticCurve_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamedEllipticCurve_descriptor_;
}
bool NamedEllipticCurve_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CryptoCipherMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoCipherMode_descriptor_;
}
bool CryptoCipherMode_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CryptoDerivingMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoDerivingMode_descriptor_;
}
bool CryptoDerivingMode_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoPurpose_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoKey_CryptoPurpose_descriptor_;
}
bool CryptoKey_CryptoPurpose_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CryptoKey_CryptoPurpose CryptoKey::VERIFYING;
const CryptoKey_CryptoPurpose CryptoKey::SIGNING;
const CryptoKey_CryptoPurpose CryptoKey::CRYPTING;
const CryptoKey_CryptoPurpose CryptoKey::DERIVING;
const CryptoKey_CryptoPurpose CryptoKey::CryptoPurpose_MIN;
const CryptoKey_CryptoPurpose CryptoKey::CryptoPurpose_MAX;
const int CryptoKey::CryptoPurpose_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* CryptoKey_CryptoAlgorithm_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoKey_CryptoAlgorithm_descriptor_;
}
bool CryptoKey_CryptoAlgorithm_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CryptoKey_CryptoAlgorithm CryptoKey::ECDSA_SHA;
const CryptoKey_CryptoAlgorithm CryptoKey::AES_CTR_HMAC_SHA;
const CryptoKey_CryptoAlgorithm CryptoKey::HMAC_SHA;
const CryptoKey_CryptoAlgorithm CryptoKey::CryptoAlgorithm_MIN;
const CryptoKey_CryptoAlgorithm CryptoKey::CryptoAlgorithm_MAX;
const int CryptoKey::CryptoAlgorithm_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CryptoKey::kVersionFieldNumber;
const int CryptoKey::kPurposeFieldNumber;
const int CryptoKey::kAlgorithmFieldNumber;
const int CryptoKey::kKeyFieldNumber;
#endif  // !_MSC_VER

CryptoKey::CryptoKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptoKey::InitAsDefaultInstance() {
}

CryptoKey::CryptoKey(const CryptoKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptoKey::SharedCtor() {
  _cached_size_ = 0;
  version_ = 1;
  purpose_ = 1;
  algorithm_ = 1;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptoKey::~CryptoKey() {
  SharedDtor();
}

void CryptoKey::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void CryptoKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptoKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoKey_descriptor_;
}

const CryptoKey& CryptoKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

CryptoKey* CryptoKey::default_instance_ = NULL;

CryptoKey* CryptoKey::New() const {
  return new CryptoKey;
}

void CryptoKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 1;
    purpose_ = 1;
    algorithm_ = 1;
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptoKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoVersion version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoVersion_IsValid(value)) {
            set_version(static_cast< ::tao::CryptoVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_purpose;
        break;
      }

      // required .tao.CryptoKey.CryptoPurpose purpose = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_purpose:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoKey_CryptoPurpose_IsValid(value)) {
            set_purpose(static_cast< ::tao::CryptoKey_CryptoPurpose >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_algorithm;
        break;
      }

      // required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_algorithm:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoKey_CryptoAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::tao::CryptoKey_CryptoAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_key;
        break;
      }

      // required bytes key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptoKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // required .tao.CryptoKey.CryptoPurpose purpose = 2;
  if (has_purpose()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->purpose(), output);
  }

  // required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
  if (has_algorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->algorithm(), output);
  }

  // required bytes key = 4;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptoKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // required .tao.CryptoKey.CryptoPurpose purpose = 2;
  if (has_purpose()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->purpose(), target);
  }

  // required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
  if (has_algorithm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->algorithm(), target);
  }

  // required bytes key = 4;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptoKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoVersion version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // required .tao.CryptoKey.CryptoPurpose purpose = 2;
    if (has_purpose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->purpose());
    }

    // required .tao.CryptoKey.CryptoAlgorithm algorithm = 3;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // required bytes key = 4;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptoKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptoKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptoKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptoKey::MergeFrom(const CryptoKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_purpose()) {
      set_purpose(from.purpose());
    }
    if (from.has_algorithm()) {
      set_algorithm(from.algorithm());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptoKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptoKey::CopyFrom(const CryptoKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CryptoKey::Swap(CryptoKey* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(purpose_, other->purpose_);
    std::swap(algorithm_, other->algorithm_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptoKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptoKey_descriptor_;
  metadata.reflection = CryptoKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CryptoKeyset::kKeysFieldNumber;
const int CryptoKeyset::kDelegationFieldNumber;
#endif  // !_MSC_VER

CryptoKeyset::CryptoKeyset()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptoKeyset::InitAsDefaultInstance() {
  delegation_ = const_cast< ::tao::Attestation*>(&::tao::Attestation::default_instance());
}

CryptoKeyset::CryptoKeyset(const CryptoKeyset& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptoKeyset::SharedCtor() {
  _cached_size_ = 0;
  delegation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptoKeyset::~CryptoKeyset() {
  SharedDtor();
}

void CryptoKeyset::SharedDtor() {
  if (this != default_instance_) {
    delete delegation_;
  }
}

void CryptoKeyset::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptoKeyset::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoKeyset_descriptor_;
}

const CryptoKeyset& CryptoKeyset::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

CryptoKeyset* CryptoKeyset::default_instance_ = NULL;

CryptoKeyset* CryptoKeyset::New() const {
  return new CryptoKeyset;
}

void CryptoKeyset::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_delegation()) {
      if (delegation_ != NULL) delegation_->::tao::Attestation::Clear();
    }
  }
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptoKeyset::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tao.CryptoKey keys = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_keys;
        if (input->ExpectTag(18)) goto parse_delegation;
        break;
      }

      // optional .tao.Attestation delegation = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_delegation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delegation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptoKeyset::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tao.CryptoKey keys = 1;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keys(i), output);
  }

  // optional .tao.Attestation delegation = 2;
  if (has_delegation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->delegation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptoKeyset::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tao.CryptoKey keys = 1;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keys(i), target);
  }

  // optional .tao.Attestation delegation = 2;
  if (has_delegation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->delegation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptoKeyset::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .tao.Attestation delegation = 2;
    if (has_delegation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->delegation());
    }

  }
  // repeated .tao.CryptoKey keys = 1;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keys(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptoKeyset::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptoKeyset* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptoKeyset*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptoKeyset::MergeFrom(const CryptoKeyset& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_delegation()) {
      mutable_delegation()->::tao::Attestation::MergeFrom(from.delegation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptoKeyset::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptoKeyset::CopyFrom(const CryptoKeyset& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoKeyset::IsInitialized() const {

  for (int i = 0; i < keys_size(); i++) {
    if (!this->keys(i).IsInitialized()) return false;
  }
  if (has_delegation()) {
    if (!this->delegation().IsInitialized()) return false;
  }
  return true;
}

void CryptoKeyset::Swap(CryptoKeyset* other) {
  if (other != this) {
    keys_.Swap(&other->keys_);
    std::swap(delegation_, other->delegation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptoKeyset::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptoKeyset_descriptor_;
  metadata.reflection = CryptoKeyset_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PBEData::kVersionFieldNumber;
const int PBEData::kCipherFieldNumber;
const int PBEData::kHmacFieldNumber;
const int PBEData::kIterationsFieldNumber;
const int PBEData::kIvFieldNumber;
const int PBEData::kCiphertextFieldNumber;
const int PBEData::kSaltFieldNumber;
#endif  // !_MSC_VER

PBEData::PBEData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PBEData::InitAsDefaultInstance() {
}

PBEData::PBEData(const PBEData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PBEData::SharedCtor() {
  _cached_size_ = 0;
  version_ = 1;
  cipher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iterations_ = 0;
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PBEData::~PBEData() {
  SharedDtor();
}

void PBEData::SharedDtor() {
  if (cipher_ != &::google::protobuf::internal::kEmptyString) {
    delete cipher_;
  }
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_;
  }
  if (this != default_instance_) {
  }
}

void PBEData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PBEData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PBEData_descriptor_;
}

const PBEData& PBEData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

PBEData* PBEData::default_instance_ = NULL;

PBEData* PBEData::New() const {
  return new PBEData;
}

void PBEData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 1;
    if (has_cipher()) {
      if (cipher_ != &::google::protobuf::internal::kEmptyString) {
        cipher_->clear();
      }
    }
    if (has_hmac()) {
      if (hmac_ != &::google::protobuf::internal::kEmptyString) {
        hmac_->clear();
      }
    }
    iterations_ = 0;
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
    if (has_ciphertext()) {
      if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
        ciphertext_->clear();
      }
    }
    if (has_salt()) {
      if (salt_ != &::google::protobuf::internal::kEmptyString) {
        salt_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PBEData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoVersion version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoVersion_IsValid(value)) {
            set_version(static_cast< ::tao::CryptoVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cipher;
        break;
      }

      // required string cipher = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cipher:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cipher()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cipher().data(), this->cipher().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_hmac;
        break;
      }

      // required string hmac = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hmac:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hmac()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hmac().data(), this->hmac().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_iterations;
        break;
      }

      // required int32 iterations = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_iterations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &iterations_)));
          set_has_iterations();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_iv;
        break;
      }

      // required bytes iv = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ciphertext;
        break;
      }

      // required bytes ciphertext = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ciphertext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ciphertext()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_salt;
        break;
      }

      // required bytes salt = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_salt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PBEData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // required string cipher = 2;
  if (has_cipher()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipher().data(), this->cipher().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cipher(), output);
  }

  // required string hmac = 3;
  if (has_hmac()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hmac().data(), this->hmac().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->hmac(), output);
  }

  // required int32 iterations = 4;
  if (has_iterations()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->iterations(), output);
  }

  // required bytes iv = 5;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->iv(), output);
  }

  // required bytes ciphertext = 6;
  if (has_ciphertext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->ciphertext(), output);
  }

  // required bytes salt = 7;
  if (has_salt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->salt(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PBEData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // required string cipher = 2;
  if (has_cipher()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipher().data(), this->cipher().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cipher(), target);
  }

  // required string hmac = 3;
  if (has_hmac()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hmac().data(), this->hmac().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->hmac(), target);
  }

  // required int32 iterations = 4;
  if (has_iterations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->iterations(), target);
  }

  // required bytes iv = 5;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->iv(), target);
  }

  // required bytes ciphertext = 6;
  if (has_ciphertext()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->ciphertext(), target);
  }

  // required bytes salt = 7;
  if (has_salt()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->salt(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PBEData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoVersion version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // required string cipher = 2;
    if (has_cipher()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cipher());
    }

    // required string hmac = 3;
    if (has_hmac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hmac());
    }

    // required int32 iterations = 4;
    if (has_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->iterations());
    }

    // required bytes iv = 5;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // required bytes ciphertext = 6;
    if (has_ciphertext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ciphertext());
    }

    // required bytes salt = 7;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->salt());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PBEData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PBEData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PBEData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PBEData::MergeFrom(const PBEData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_cipher()) {
      set_cipher(from.cipher());
    }
    if (from.has_hmac()) {
      set_hmac(from.hmac());
    }
    if (from.has_iterations()) {
      set_iterations(from.iterations());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
    if (from.has_ciphertext()) {
      set_ciphertext(from.ciphertext());
    }
    if (from.has_salt()) {
      set_salt(from.salt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PBEData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PBEData::CopyFrom(const PBEData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PBEData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void PBEData::Swap(PBEData* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(cipher_, other->cipher_);
    std::swap(hmac_, other->hmac_);
    std::swap(iterations_, other->iterations_);
    std::swap(iv_, other->iv_);
    std::swap(ciphertext_, other->ciphertext_);
    std::swap(salt_, other->salt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PBEData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PBEData_descriptor_;
  metadata.reflection = PBEData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ECDSA_SHA_VerifyingKey_v1::kCurveFieldNumber;
const int ECDSA_SHA_VerifyingKey_v1::kEcPublicFieldNumber;
#endif  // !_MSC_VER

ECDSA_SHA_VerifyingKey_v1::ECDSA_SHA_VerifyingKey_v1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ECDSA_SHA_VerifyingKey_v1::InitAsDefaultInstance() {
}

ECDSA_SHA_VerifyingKey_v1::ECDSA_SHA_VerifyingKey_v1(const ECDSA_SHA_VerifyingKey_v1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ECDSA_SHA_VerifyingKey_v1::SharedCtor() {
  _cached_size_ = 0;
  curve_ = 1;
  ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ECDSA_SHA_VerifyingKey_v1::~ECDSA_SHA_VerifyingKey_v1() {
  SharedDtor();
}

void ECDSA_SHA_VerifyingKey_v1::SharedDtor() {
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_public_;
  }
  if (this != default_instance_) {
  }
}

void ECDSA_SHA_VerifyingKey_v1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECDSA_SHA_VerifyingKey_v1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECDSA_SHA_VerifyingKey_v1_descriptor_;
}

const ECDSA_SHA_VerifyingKey_v1& ECDSA_SHA_VerifyingKey_v1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

ECDSA_SHA_VerifyingKey_v1* ECDSA_SHA_VerifyingKey_v1::default_instance_ = NULL;

ECDSA_SHA_VerifyingKey_v1* ECDSA_SHA_VerifyingKey_v1::New() const {
  return new ECDSA_SHA_VerifyingKey_v1;
}

void ECDSA_SHA_VerifyingKey_v1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    curve_ = 1;
    if (has_ec_public()) {
      if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
        ec_public_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ECDSA_SHA_VerifyingKey_v1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.NamedEllipticCurve curve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::NamedEllipticCurve_IsValid(value)) {
            set_curve(static_cast< ::tao::NamedEllipticCurve >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ec_public;
        break;
      }

      // required bytes ec_public = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ec_public:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ec_public()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ECDSA_SHA_VerifyingKey_v1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.NamedEllipticCurve curve = 1;
  if (has_curve()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->curve(), output);
  }

  // required bytes ec_public = 2;
  if (has_ec_public()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->ec_public(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ECDSA_SHA_VerifyingKey_v1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.NamedEllipticCurve curve = 1;
  if (has_curve()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->curve(), target);
  }

  // required bytes ec_public = 2;
  if (has_ec_public()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->ec_public(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ECDSA_SHA_VerifyingKey_v1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.NamedEllipticCurve curve = 1;
    if (has_curve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->curve());
    }

    // required bytes ec_public = 2;
    if (has_ec_public()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ec_public());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECDSA_SHA_VerifyingKey_v1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ECDSA_SHA_VerifyingKey_v1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ECDSA_SHA_VerifyingKey_v1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ECDSA_SHA_VerifyingKey_v1::MergeFrom(const ECDSA_SHA_VerifyingKey_v1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_curve()) {
      set_curve(from.curve());
    }
    if (from.has_ec_public()) {
      set_ec_public(from.ec_public());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ECDSA_SHA_VerifyingKey_v1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECDSA_SHA_VerifyingKey_v1::CopyFrom(const ECDSA_SHA_VerifyingKey_v1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECDSA_SHA_VerifyingKey_v1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ECDSA_SHA_VerifyingKey_v1::Swap(ECDSA_SHA_VerifyingKey_v1* other) {
  if (other != this) {
    std::swap(curve_, other->curve_);
    std::swap(ec_public_, other->ec_public_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ECDSA_SHA_VerifyingKey_v1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ECDSA_SHA_VerifyingKey_v1_descriptor_;
  metadata.reflection = ECDSA_SHA_VerifyingKey_v1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ECDSA_SHA_SigningKey_v1::kCurveFieldNumber;
const int ECDSA_SHA_SigningKey_v1::kEcPrivateFieldNumber;
const int ECDSA_SHA_SigningKey_v1::kEcPublicFieldNumber;
#endif  // !_MSC_VER

ECDSA_SHA_SigningKey_v1::ECDSA_SHA_SigningKey_v1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ECDSA_SHA_SigningKey_v1::InitAsDefaultInstance() {
}

ECDSA_SHA_SigningKey_v1::ECDSA_SHA_SigningKey_v1(const ECDSA_SHA_SigningKey_v1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ECDSA_SHA_SigningKey_v1::SharedCtor() {
  _cached_size_ = 0;
  curve_ = 1;
  ec_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ec_public_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ECDSA_SHA_SigningKey_v1::~ECDSA_SHA_SigningKey_v1() {
  SharedDtor();
}

void ECDSA_SHA_SigningKey_v1::SharedDtor() {
  if (ec_private_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_private_;
  }
  if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
    delete ec_public_;
  }
  if (this != default_instance_) {
  }
}

void ECDSA_SHA_SigningKey_v1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECDSA_SHA_SigningKey_v1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECDSA_SHA_SigningKey_v1_descriptor_;
}

const ECDSA_SHA_SigningKey_v1& ECDSA_SHA_SigningKey_v1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

ECDSA_SHA_SigningKey_v1* ECDSA_SHA_SigningKey_v1::default_instance_ = NULL;

ECDSA_SHA_SigningKey_v1* ECDSA_SHA_SigningKey_v1::New() const {
  return new ECDSA_SHA_SigningKey_v1;
}

void ECDSA_SHA_SigningKey_v1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    curve_ = 1;
    if (has_ec_private()) {
      if (ec_private_ != &::google::protobuf::internal::kEmptyString) {
        ec_private_->clear();
      }
    }
    if (has_ec_public()) {
      if (ec_public_ != &::google::protobuf::internal::kEmptyString) {
        ec_public_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ECDSA_SHA_SigningKey_v1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.NamedEllipticCurve curve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::NamedEllipticCurve_IsValid(value)) {
            set_curve(static_cast< ::tao::NamedEllipticCurve >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ec_private;
        break;
      }

      // required bytes ec_private = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ec_private:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ec_private()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ec_public;
        break;
      }

      // required bytes ec_public = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ec_public:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ec_public()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ECDSA_SHA_SigningKey_v1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.NamedEllipticCurve curve = 1;
  if (has_curve()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->curve(), output);
  }

  // required bytes ec_private = 2;
  if (has_ec_private()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->ec_private(), output);
  }

  // required bytes ec_public = 3;
  if (has_ec_public()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ec_public(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ECDSA_SHA_SigningKey_v1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.NamedEllipticCurve curve = 1;
  if (has_curve()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->curve(), target);
  }

  // required bytes ec_private = 2;
  if (has_ec_private()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->ec_private(), target);
  }

  // required bytes ec_public = 3;
  if (has_ec_public()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ec_public(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ECDSA_SHA_SigningKey_v1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.NamedEllipticCurve curve = 1;
    if (has_curve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->curve());
    }

    // required bytes ec_private = 2;
    if (has_ec_private()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ec_private());
    }

    // required bytes ec_public = 3;
    if (has_ec_public()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ec_public());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECDSA_SHA_SigningKey_v1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ECDSA_SHA_SigningKey_v1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ECDSA_SHA_SigningKey_v1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ECDSA_SHA_SigningKey_v1::MergeFrom(const ECDSA_SHA_SigningKey_v1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_curve()) {
      set_curve(from.curve());
    }
    if (from.has_ec_private()) {
      set_ec_private(from.ec_private());
    }
    if (from.has_ec_public()) {
      set_ec_public(from.ec_public());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ECDSA_SHA_SigningKey_v1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECDSA_SHA_SigningKey_v1::CopyFrom(const ECDSA_SHA_SigningKey_v1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECDSA_SHA_SigningKey_v1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ECDSA_SHA_SigningKey_v1::Swap(ECDSA_SHA_SigningKey_v1* other) {
  if (other != this) {
    std::swap(curve_, other->curve_);
    std::swap(ec_private_, other->ec_private_);
    std::swap(ec_public_, other->ec_public_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ECDSA_SHA_SigningKey_v1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ECDSA_SHA_SigningKey_v1_descriptor_;
  metadata.reflection = ECDSA_SHA_SigningKey_v1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AES_CTR_HMAC_SHA_CryptingKey_v1::kModeFieldNumber;
const int AES_CTR_HMAC_SHA_CryptingKey_v1::kAesPrivateFieldNumber;
const int AES_CTR_HMAC_SHA_CryptingKey_v1::kHmacPrivateFieldNumber;
#endif  // !_MSC_VER

AES_CTR_HMAC_SHA_CryptingKey_v1::AES_CTR_HMAC_SHA_CryptingKey_v1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::InitAsDefaultInstance() {
}

AES_CTR_HMAC_SHA_CryptingKey_v1::AES_CTR_HMAC_SHA_CryptingKey_v1(const AES_CTR_HMAC_SHA_CryptingKey_v1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 1;
  aes_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AES_CTR_HMAC_SHA_CryptingKey_v1::~AES_CTR_HMAC_SHA_CryptingKey_v1() {
  SharedDtor();
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::SharedDtor() {
  if (aes_private_ != &::google::protobuf::internal::kEmptyString) {
    delete aes_private_;
  }
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_private_;
  }
  if (this != default_instance_) {
  }
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AES_CTR_HMAC_SHA_CryptingKey_v1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_;
}

const AES_CTR_HMAC_SHA_CryptingKey_v1& AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

AES_CTR_HMAC_SHA_CryptingKey_v1* AES_CTR_HMAC_SHA_CryptingKey_v1::default_instance_ = NULL;

AES_CTR_HMAC_SHA_CryptingKey_v1* AES_CTR_HMAC_SHA_CryptingKey_v1::New() const {
  return new AES_CTR_HMAC_SHA_CryptingKey_v1;
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mode_ = 1;
    if (has_aes_private()) {
      if (aes_private_ != &::google::protobuf::internal::kEmptyString) {
        aes_private_->clear();
      }
    }
    if (has_hmac_private()) {
      if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
        hmac_private_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AES_CTR_HMAC_SHA_CryptingKey_v1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoCipherMode mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoCipherMode_IsValid(value)) {
            set_mode(static_cast< ::tao::CryptoCipherMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_aes_private;
        break;
      }

      // required bytes aes_private = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aes_private:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes_private()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_hmac_private;
        break;
      }

      // required bytes hmac_private = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hmac_private:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hmac_private()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoCipherMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required bytes aes_private = 2;
  if (has_aes_private()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->aes_private(), output);
  }

  // required bytes hmac_private = 3;
  if (has_hmac_private()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->hmac_private(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AES_CTR_HMAC_SHA_CryptingKey_v1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoCipherMode mode = 1;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->mode(), target);
  }

  // required bytes aes_private = 2;
  if (has_aes_private()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->aes_private(), target);
  }

  // required bytes hmac_private = 3;
  if (has_hmac_private()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->hmac_private(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AES_CTR_HMAC_SHA_CryptingKey_v1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoCipherMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required bytes aes_private = 2;
    if (has_aes_private()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes_private());
    }

    // required bytes hmac_private = 3;
    if (has_hmac_private()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hmac_private());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AES_CTR_HMAC_SHA_CryptingKey_v1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AES_CTR_HMAC_SHA_CryptingKey_v1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::MergeFrom(const AES_CTR_HMAC_SHA_CryptingKey_v1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_aes_private()) {
      set_aes_private(from.aes_private());
    }
    if (from.has_hmac_private()) {
      set_hmac_private(from.hmac_private());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::CopyFrom(const AES_CTR_HMAC_SHA_CryptingKey_v1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AES_CTR_HMAC_SHA_CryptingKey_v1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AES_CTR_HMAC_SHA_CryptingKey_v1::Swap(AES_CTR_HMAC_SHA_CryptingKey_v1* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(aes_private_, other->aes_private_);
    std::swap(hmac_private_, other->hmac_private_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AES_CTR_HMAC_SHA_CryptingKey_v1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AES_CTR_HMAC_SHA_CryptingKey_v1_descriptor_;
  metadata.reflection = AES_CTR_HMAC_SHA_CryptingKey_v1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HMAC_SHA_DerivingKey_v1::kModeFieldNumber;
const int HMAC_SHA_DerivingKey_v1::kHmacPrivateFieldNumber;
#endif  // !_MSC_VER

HMAC_SHA_DerivingKey_v1::HMAC_SHA_DerivingKey_v1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HMAC_SHA_DerivingKey_v1::InitAsDefaultInstance() {
}

HMAC_SHA_DerivingKey_v1::HMAC_SHA_DerivingKey_v1(const HMAC_SHA_DerivingKey_v1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HMAC_SHA_DerivingKey_v1::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 1;
  hmac_private_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HMAC_SHA_DerivingKey_v1::~HMAC_SHA_DerivingKey_v1() {
  SharedDtor();
}

void HMAC_SHA_DerivingKey_v1::SharedDtor() {
  if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_private_;
  }
  if (this != default_instance_) {
  }
}

void HMAC_SHA_DerivingKey_v1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HMAC_SHA_DerivingKey_v1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HMAC_SHA_DerivingKey_v1_descriptor_;
}

const HMAC_SHA_DerivingKey_v1& HMAC_SHA_DerivingKey_v1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

HMAC_SHA_DerivingKey_v1* HMAC_SHA_DerivingKey_v1::default_instance_ = NULL;

HMAC_SHA_DerivingKey_v1* HMAC_SHA_DerivingKey_v1::New() const {
  return new HMAC_SHA_DerivingKey_v1;
}

void HMAC_SHA_DerivingKey_v1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mode_ = 1;
    if (has_hmac_private()) {
      if (hmac_private_ != &::google::protobuf::internal::kEmptyString) {
        hmac_private_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HMAC_SHA_DerivingKey_v1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoDerivingMode mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoDerivingMode_IsValid(value)) {
            set_mode(static_cast< ::tao::CryptoDerivingMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hmac_private;
        break;
      }

      // required bytes hmac_private = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hmac_private:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hmac_private()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HMAC_SHA_DerivingKey_v1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoDerivingMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required bytes hmac_private = 2;
  if (has_hmac_private()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->hmac_private(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HMAC_SHA_DerivingKey_v1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoDerivingMode mode = 1;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->mode(), target);
  }

  // required bytes hmac_private = 2;
  if (has_hmac_private()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hmac_private(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HMAC_SHA_DerivingKey_v1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoDerivingMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required bytes hmac_private = 2;
    if (has_hmac_private()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hmac_private());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HMAC_SHA_DerivingKey_v1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HMAC_SHA_DerivingKey_v1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HMAC_SHA_DerivingKey_v1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HMAC_SHA_DerivingKey_v1::MergeFrom(const HMAC_SHA_DerivingKey_v1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_hmac_private()) {
      set_hmac_private(from.hmac_private());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HMAC_SHA_DerivingKey_v1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HMAC_SHA_DerivingKey_v1::CopyFrom(const HMAC_SHA_DerivingKey_v1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HMAC_SHA_DerivingKey_v1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HMAC_SHA_DerivingKey_v1::Swap(HMAC_SHA_DerivingKey_v1* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(hmac_private_, other->hmac_private_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HMAC_SHA_DerivingKey_v1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HMAC_SHA_DerivingKey_v1_descriptor_;
  metadata.reflection = HMAC_SHA_DerivingKey_v1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CryptoHeader::kVersionFieldNumber;
const int CryptoHeader::kKeyHintFieldNumber;
#endif  // !_MSC_VER

CryptoHeader::CryptoHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptoHeader::InitAsDefaultInstance() {
}

CryptoHeader::CryptoHeader(const CryptoHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptoHeader::SharedCtor() {
  _cached_size_ = 0;
  version_ = 1;
  key_hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptoHeader::~CryptoHeader() {
  SharedDtor();
}

void CryptoHeader::SharedDtor() {
  if (key_hint_ != &::google::protobuf::internal::kEmptyString) {
    delete key_hint_;
  }
  if (this != default_instance_) {
  }
}

void CryptoHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptoHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoHeader_descriptor_;
}

const CryptoHeader& CryptoHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

CryptoHeader* CryptoHeader::default_instance_ = NULL;

CryptoHeader* CryptoHeader::New() const {
  return new CryptoHeader;
}

void CryptoHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 1;
    if (has_key_hint()) {
      if (key_hint_ != &::google::protobuf::internal::kEmptyString) {
        key_hint_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptoHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoVersion version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tao::CryptoVersion_IsValid(value)) {
            set_version(static_cast< ::tao::CryptoVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key_hint;
        break;
      }

      // required bytes key_hint = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_hint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key_hint()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptoHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // required bytes key_hint = 2;
  if (has_key_hint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->key_hint(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptoHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoVersion version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // required bytes key_hint = 2;
  if (has_key_hint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key_hint(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptoHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoVersion version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // required bytes key_hint = 2;
    if (has_key_hint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key_hint());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptoHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptoHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptoHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptoHeader::MergeFrom(const CryptoHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_key_hint()) {
      set_key_hint(from.key_hint());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptoHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptoHeader::CopyFrom(const CryptoHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CryptoHeader::Swap(CryptoHeader* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(key_hint_, other->key_hint_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptoHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptoHeader_descriptor_;
  metadata.reflection = CryptoHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignaturePDU::kHeaderFieldNumber;
const int SignaturePDU::kContextFieldNumber;
const int SignaturePDU::kDataFieldNumber;
#endif  // !_MSC_VER

SignaturePDU::SignaturePDU()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignaturePDU::InitAsDefaultInstance() {
  header_ = const_cast< ::tao::CryptoHeader*>(&::tao::CryptoHeader::default_instance());
}

SignaturePDU::SignaturePDU(const SignaturePDU& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignaturePDU::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignaturePDU::~SignaturePDU() {
  SharedDtor();
}

void SignaturePDU::SharedDtor() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void SignaturePDU::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignaturePDU::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignaturePDU_descriptor_;
}

const SignaturePDU& SignaturePDU::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

SignaturePDU* SignaturePDU::default_instance_ = NULL;

SignaturePDU* SignaturePDU::New() const {
  return new SignaturePDU;
}

void SignaturePDU::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
    }
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::kEmptyString) {
        context_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignaturePDU::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_context;
        break;
      }

      // required string context = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_context()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->context().data(), this->context().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignaturePDU::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // required string context = 2;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->context(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignaturePDU::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // required string context = 2;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->context(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignaturePDU::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // required string context = 2;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->context());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignaturePDU::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignaturePDU* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignaturePDU*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignaturePDU::MergeFrom(const SignaturePDU& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::tao::CryptoHeader::MergeFrom(from.header());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignaturePDU::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignaturePDU::CopyFrom(const SignaturePDU& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignaturePDU::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void SignaturePDU::Swap(SignaturePDU* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(context_, other->context_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignaturePDU::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignaturePDU_descriptor_;
  metadata.reflection = SignaturePDU_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedData::kHeaderFieldNumber;
const int SignedData::kSignatureFieldNumber;
#endif  // !_MSC_VER

SignedData::SignedData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignedData::InitAsDefaultInstance() {
  header_ = const_cast< ::tao::CryptoHeader*>(&::tao::CryptoHeader::default_instance());
}

SignedData::SignedData(const SignedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignedData::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedData::~SignedData() {
  SharedDtor();
}

void SignedData::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void SignedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedData_descriptor_;
}

const SignedData& SignedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

SignedData* SignedData::default_instance_ = NULL;

SignedData* SignedData::New() const {
  return new SignedData;
}

void SignedData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // required bytes signature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // required bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // required bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // required bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedData::MergeFrom(const SignedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::tao::CryptoHeader::MergeFrom(from.header());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedData::CopyFrom(const SignedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void SignedData::Swap(SignedData* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedData_descriptor_;
  metadata.reflection = SignedData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EncryptedData::kHeaderFieldNumber;
const int EncryptedData::kIvFieldNumber;
const int EncryptedData::kCiphertextFieldNumber;
const int EncryptedData::kMacFieldNumber;
#endif  // !_MSC_VER

EncryptedData::EncryptedData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EncryptedData::InitAsDefaultInstance() {
  header_ = const_cast< ::tao::CryptoHeader*>(&::tao::CryptoHeader::default_instance());
}

EncryptedData::EncryptedData(const EncryptedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EncryptedData::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncryptedData::~EncryptedData() {
  SharedDtor();
}

void EncryptedData::SharedDtor() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void EncryptedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EncryptedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EncryptedData_descriptor_;
}

const EncryptedData& EncryptedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

EncryptedData* EncryptedData::default_instance_ = NULL;

EncryptedData* EncryptedData::New() const {
  return new EncryptedData;
}

void EncryptedData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::tao::CryptoHeader::Clear();
    }
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
    if (has_ciphertext()) {
      if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
        ciphertext_->clear();
      }
    }
    if (has_mac()) {
      if (mac_ != &::google::protobuf::internal::kEmptyString) {
        mac_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EncryptedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tao.CryptoHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iv;
        break;
      }

      // required bytes iv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ciphertext;
        break;
      }

      // required bytes ciphertext = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ciphertext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ciphertext()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_mac;
        break;
      }

      // optional bytes mac = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mac:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EncryptedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->iv(), output);
  }

  // required bytes ciphertext = 3;
  if (has_ciphertext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ciphertext(), output);
  }

  // optional bytes mac = 4;
  if (has_mac()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->mac(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EncryptedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tao.CryptoHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->iv(), target);
  }

  // required bytes ciphertext = 3;
  if (has_ciphertext()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ciphertext(), target);
  }

  // optional bytes mac = 4;
  if (has_mac()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->mac(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EncryptedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tao.CryptoHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // required bytes iv = 2;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // required bytes ciphertext = 3;
    if (has_ciphertext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ciphertext());
    }

    // optional bytes mac = 4;
    if (has_mac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mac());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncryptedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EncryptedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EncryptedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EncryptedData::MergeFrom(const EncryptedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::tao::CryptoHeader::MergeFrom(from.header());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
    if (from.has_ciphertext()) {
      set_ciphertext(from.ciphertext());
    }
    if (from.has_mac()) {
      set_mac(from.mac());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EncryptedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptedData::CopyFrom(const EncryptedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptedData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void EncryptedData::Swap(EncryptedData* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(iv_, other->iv_);
    std::swap(ciphertext_, other->ciphertext_);
    std::swap(mac_, other->mac_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EncryptedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EncryptedData_descriptor_;
  metadata.reflection = EncryptedData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyDerivationPDU::kPreviousHashFieldNumber;
const int KeyDerivationPDU::kSizeFieldNumber;
const int KeyDerivationPDU::kContextFieldNumber;
const int KeyDerivationPDU::kIndexFieldNumber;
#endif  // !_MSC_VER

KeyDerivationPDU::KeyDerivationPDU()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyDerivationPDU::InitAsDefaultInstance() {
}

KeyDerivationPDU::KeyDerivationPDU(const KeyDerivationPDU& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyDerivationPDU::SharedCtor() {
  _cached_size_ = 0;
  previous_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  size_ = 0u;
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyDerivationPDU::~KeyDerivationPDU() {
  SharedDtor();
}

void KeyDerivationPDU::SharedDtor() {
  if (previous_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete previous_hash_;
  }
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (this != default_instance_) {
  }
}

void KeyDerivationPDU::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyDerivationPDU::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyDerivationPDU_descriptor_;
}

const KeyDerivationPDU& KeyDerivationPDU::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_keys_2eproto();
  return *default_instance_;
}

KeyDerivationPDU* KeyDerivationPDU::default_instance_ = NULL;

KeyDerivationPDU* KeyDerivationPDU::New() const {
  return new KeyDerivationPDU;
}

void KeyDerivationPDU::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_previous_hash()) {
      if (previous_hash_ != &::google::protobuf::internal::kEmptyString) {
        previous_hash_->clear();
      }
    }
    size_ = 0u;
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::kEmptyString) {
        context_->clear();
      }
    }
    index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyDerivationPDU::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes previous_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_previous_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_size;
        break;
      }

      // required fixed32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_context;
        break;
      }

      // required string context = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_context()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->context().data(), this->context().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_index;
        break;
      }

      // required fixed32 index = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyDerivationPDU::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes previous_hash = 1;
  if (has_previous_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->previous_hash(), output);
  }

  // required fixed32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->size(), output);
  }

  // required string context = 3;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->context(), output);
  }

  // required fixed32 index = 4;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyDerivationPDU::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes previous_hash = 1;
  if (has_previous_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->previous_hash(), target);
  }

  // required fixed32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->size(), target);
  }

  // required string context = 3;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->context(), target);
  }

  // required fixed32 index = 4;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyDerivationPDU::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes previous_hash = 1;
    if (has_previous_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->previous_hash());
    }

    // required fixed32 size = 2;
    if (has_size()) {
      total_size += 1 + 4;
    }

    // required string context = 3;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->context());
    }

    // required fixed32 index = 4;
    if (has_index()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyDerivationPDU::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyDerivationPDU* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyDerivationPDU*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyDerivationPDU::MergeFrom(const KeyDerivationPDU& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_previous_hash()) {
      set_previous_hash(from.previous_hash());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyDerivationPDU::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyDerivationPDU::CopyFrom(const KeyDerivationPDU& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyDerivationPDU::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void KeyDerivationPDU::Swap(KeyDerivationPDU* other) {
  if (other != this) {
    std::swap(previous_hash_, other->previous_hash_);
    std::swap(size_, other->size_);
    std::swap(context_, other->context_);
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyDerivationPDU::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyDerivationPDU_descriptor_;
  metadata.reflection = KeyDerivationPDU_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tao

// @@protoc_insertion_point(global_scope)
