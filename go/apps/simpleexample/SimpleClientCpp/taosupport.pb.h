// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: taosupport.proto

#ifndef PROTOBUF_taosupport_2eproto__INCLUDED
#define PROTOBUF_taosupport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace taosupport {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_taosupport_2eproto();
void protobuf_AssignDesc_taosupport_2eproto();
void protobuf_ShutdownFile_taosupport_2eproto();

class SimpleMessage;
class RsaPrivateKeyMessage;
class EcPrivateKeyMessage;
class PrivateKeyMessage;

enum MessageType {
  REQUEST = 1,
  RESPONSE = 2
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = REQUEST;
const MessageType MessageType_MAX = RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class SimpleMessage : public ::google::protobuf::Message {
 public:
  SimpleMessage();
  virtual ~SimpleMessage();

  SimpleMessage(const SimpleMessage& from);

  inline SimpleMessage& operator=(const SimpleMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleMessage& default_instance();

  void Swap(SimpleMessage* other);

  // implements Message ----------------------------------------------

  SimpleMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleMessage& from);
  void MergeFrom(const SimpleMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);

  // required string request_type = 2;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 2;
  inline const ::std::string& request_type() const;
  inline void set_request_type(const ::std::string& value);
  inline void set_request_type(const char* value);
  inline void set_request_type(const char* value, size_t size);
  inline ::std::string* mutable_request_type();
  inline ::std::string* release_request_type();
  inline void set_allocated_request_type(::std::string* request_type);

  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  inline void set_allocated_err(::std::string* err);

  // repeated bytes data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:taosupport.SimpleMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_type_;
  ::std::string* err_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  ::google::protobuf::int32 message_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_taosupport_2eproto();
  friend void protobuf_AssignDesc_taosupport_2eproto();
  friend void protobuf_ShutdownFile_taosupport_2eproto();

  void InitAsDefaultInstance();
  static SimpleMessage* default_instance_;
};
// -------------------------------------------------------------------

class RsaPrivateKeyMessage : public ::google::protobuf::Message {
 public:
  RsaPrivateKeyMessage();
  virtual ~RsaPrivateKeyMessage();

  RsaPrivateKeyMessage(const RsaPrivateKeyMessage& from);

  inline RsaPrivateKeyMessage& operator=(const RsaPrivateKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RsaPrivateKeyMessage& default_instance();

  void Swap(RsaPrivateKeyMessage* other);

  // implements Message ----------------------------------------------

  RsaPrivateKeyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RsaPrivateKeyMessage& from);
  void MergeFrom(const RsaPrivateKeyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline const ::std::string& m() const;
  inline void set_m(const ::std::string& value);
  inline void set_m(const char* value);
  inline void set_m(const void* value, size_t size);
  inline ::std::string* mutable_m();
  inline ::std::string* release_m();
  inline void set_allocated_m(::std::string* m);

  // optional bytes e = 2;
  inline bool has_e() const;
  inline void clear_e();
  static const int kEFieldNumber = 2;
  inline const ::std::string& e() const;
  inline void set_e(const ::std::string& value);
  inline void set_e(const char* value);
  inline void set_e(const void* value, size_t size);
  inline ::std::string* mutable_e();
  inline ::std::string* release_e();
  inline void set_allocated_e(::std::string* e);

  // optional bytes d = 3;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 3;
  inline const ::std::string& d() const;
  inline void set_d(const ::std::string& value);
  inline void set_d(const char* value);
  inline void set_d(const void* value, size_t size);
  inline ::std::string* mutable_d();
  inline ::std::string* release_d();
  inline void set_allocated_d(::std::string* d);

  // optional bytes p = 4;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 4;
  inline const ::std::string& p() const;
  inline void set_p(const ::std::string& value);
  inline void set_p(const char* value);
  inline void set_p(const void* value, size_t size);
  inline ::std::string* mutable_p();
  inline ::std::string* release_p();
  inline void set_allocated_p(::std::string* p);

  // optional bytes q = 5;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 5;
  inline const ::std::string& q() const;
  inline void set_q(const ::std::string& value);
  inline void set_q(const char* value);
  inline void set_q(const void* value, size_t size);
  inline ::std::string* mutable_q();
  inline ::std::string* release_q();
  inline void set_allocated_q(::std::string* q);

  // @@protoc_insertion_point(class_scope:taosupport.RsaPrivateKeyMessage)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_e();
  inline void clear_has_e();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_q();
  inline void clear_has_q();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_;
  ::std::string* e_;
  ::std::string* d_;
  ::std::string* p_;
  ::std::string* q_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_taosupport_2eproto();
  friend void protobuf_AssignDesc_taosupport_2eproto();
  friend void protobuf_ShutdownFile_taosupport_2eproto();

  void InitAsDefaultInstance();
  static RsaPrivateKeyMessage* default_instance_;
};
// -------------------------------------------------------------------

class EcPrivateKeyMessage : public ::google::protobuf::Message {
 public:
  EcPrivateKeyMessage();
  virtual ~EcPrivateKeyMessage();

  EcPrivateKeyMessage(const EcPrivateKeyMessage& from);

  inline EcPrivateKeyMessage& operator=(const EcPrivateKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EcPrivateKeyMessage& default_instance();

  void Swap(EcPrivateKeyMessage* other);

  // implements Message ----------------------------------------------

  EcPrivateKeyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EcPrivateKeyMessage& from);
  void MergeFrom(const EcPrivateKeyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes der_blob = 1;
  inline bool has_der_blob() const;
  inline void clear_der_blob();
  static const int kDerBlobFieldNumber = 1;
  inline const ::std::string& der_blob() const;
  inline void set_der_blob(const ::std::string& value);
  inline void set_der_blob(const char* value);
  inline void set_der_blob(const void* value, size_t size);
  inline ::std::string* mutable_der_blob();
  inline ::std::string* release_der_blob();
  inline void set_allocated_der_blob(::std::string* der_blob);

  // @@protoc_insertion_point(class_scope:taosupport.EcPrivateKeyMessage)
 private:
  inline void set_has_der_blob();
  inline void clear_has_der_blob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* der_blob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_taosupport_2eproto();
  friend void protobuf_AssignDesc_taosupport_2eproto();
  friend void protobuf_ShutdownFile_taosupport_2eproto();

  void InitAsDefaultInstance();
  static EcPrivateKeyMessage* default_instance_;
};
// -------------------------------------------------------------------

class PrivateKeyMessage : public ::google::protobuf::Message {
 public:
  PrivateKeyMessage();
  virtual ~PrivateKeyMessage();

  PrivateKeyMessage(const PrivateKeyMessage& from);

  inline PrivateKeyMessage& operator=(const PrivateKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateKeyMessage& default_instance();

  void Swap(PrivateKeyMessage* other);

  // implements Message ----------------------------------------------

  PrivateKeyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateKeyMessage& from);
  void MergeFrom(const PrivateKeyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_type = 1;
  inline bool has_key_type() const;
  inline void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  inline const ::std::string& key_type() const;
  inline void set_key_type(const ::std::string& value);
  inline void set_key_type(const char* value);
  inline void set_key_type(const char* value, size_t size);
  inline ::std::string* mutable_key_type();
  inline ::std::string* release_key_type();
  inline void set_allocated_key_type(::std::string* key_type);

  // optional .taosupport.RsaPrivateKeyMessage rsa_key = 2;
  inline bool has_rsa_key() const;
  inline void clear_rsa_key();
  static const int kRsaKeyFieldNumber = 2;
  inline const ::taosupport::RsaPrivateKeyMessage& rsa_key() const;
  inline ::taosupport::RsaPrivateKeyMessage* mutable_rsa_key();
  inline ::taosupport::RsaPrivateKeyMessage* release_rsa_key();
  inline void set_allocated_rsa_key(::taosupport::RsaPrivateKeyMessage* rsa_key);

  // optional .taosupport.EcPrivateKeyMessage ec_key = 3;
  inline bool has_ec_key() const;
  inline void clear_ec_key();
  static const int kEcKeyFieldNumber = 3;
  inline const ::taosupport::EcPrivateKeyMessage& ec_key() const;
  inline ::taosupport::EcPrivateKeyMessage* mutable_ec_key();
  inline ::taosupport::EcPrivateKeyMessage* release_ec_key();
  inline void set_allocated_ec_key(::taosupport::EcPrivateKeyMessage* ec_key);

  // @@protoc_insertion_point(class_scope:taosupport.PrivateKeyMessage)
 private:
  inline void set_has_key_type();
  inline void clear_has_key_type();
  inline void set_has_rsa_key();
  inline void clear_has_rsa_key();
  inline void set_has_ec_key();
  inline void clear_has_ec_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_type_;
  ::taosupport::RsaPrivateKeyMessage* rsa_key_;
  ::taosupport::EcPrivateKeyMessage* ec_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_taosupport_2eproto();
  friend void protobuf_AssignDesc_taosupport_2eproto();
  friend void protobuf_ShutdownFile_taosupport_2eproto();

  void InitAsDefaultInstance();
  static PrivateKeyMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// SimpleMessage

// required int32 message_type = 1;
inline bool SimpleMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 SimpleMessage::message_type() const {
  return message_type_;
}
inline void SimpleMessage::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// required string request_type = 2;
inline bool SimpleMessage::has_request_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleMessage::set_has_request_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleMessage::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleMessage::clear_request_type() {
  if (request_type_ != &::google::protobuf::internal::kEmptyString) {
    request_type_->clear();
  }
  clear_has_request_type();
}
inline const ::std::string& SimpleMessage::request_type() const {
  return *request_type_;
}
inline void SimpleMessage::set_request_type(const ::std::string& value) {
  set_has_request_type();
  if (request_type_ == &::google::protobuf::internal::kEmptyString) {
    request_type_ = new ::std::string;
  }
  request_type_->assign(value);
}
inline void SimpleMessage::set_request_type(const char* value) {
  set_has_request_type();
  if (request_type_ == &::google::protobuf::internal::kEmptyString) {
    request_type_ = new ::std::string;
  }
  request_type_->assign(value);
}
inline void SimpleMessage::set_request_type(const char* value, size_t size) {
  set_has_request_type();
  if (request_type_ == &::google::protobuf::internal::kEmptyString) {
    request_type_ = new ::std::string;
  }
  request_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleMessage::mutable_request_type() {
  set_has_request_type();
  if (request_type_ == &::google::protobuf::internal::kEmptyString) {
    request_type_ = new ::std::string;
  }
  return request_type_;
}
inline ::std::string* SimpleMessage::release_request_type() {
  clear_has_request_type();
  if (request_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_type_;
    request_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SimpleMessage::set_allocated_request_type(::std::string* request_type) {
  if (request_type_ != &::google::protobuf::internal::kEmptyString) {
    delete request_type_;
  }
  if (request_type) {
    set_has_request_type();
    request_type_ = request_type;
  } else {
    clear_has_request_type();
    request_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string err = 3;
inline bool SimpleMessage::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimpleMessage::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimpleMessage::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimpleMessage::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& SimpleMessage::err() const {
  return *err_;
}
inline void SimpleMessage::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void SimpleMessage::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void SimpleMessage::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleMessage::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* SimpleMessage::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SimpleMessage::set_allocated_err(::std::string* err) {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    delete err_;
  }
  if (err) {
    set_has_err();
    err_ = err;
  } else {
    clear_has_err();
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes data = 4;
inline int SimpleMessage::data_size() const {
  return data_.size();
}
inline void SimpleMessage::clear_data() {
  data_.Clear();
}
inline const ::std::string& SimpleMessage::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* SimpleMessage::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void SimpleMessage::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void SimpleMessage::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void SimpleMessage::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleMessage::add_data() {
  return data_.Add();
}
inline void SimpleMessage::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void SimpleMessage::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void SimpleMessage::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SimpleMessage::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SimpleMessage::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// RsaPrivateKeyMessage

// optional bytes m = 1;
inline bool RsaPrivateKeyMessage::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RsaPrivateKeyMessage::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RsaPrivateKeyMessage::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RsaPrivateKeyMessage::clear_m() {
  if (m_ != &::google::protobuf::internal::kEmptyString) {
    m_->clear();
  }
  clear_has_m();
}
inline const ::std::string& RsaPrivateKeyMessage::m() const {
  return *m_;
}
inline void RsaPrivateKeyMessage::set_m(const ::std::string& value) {
  set_has_m();
  if (m_ == &::google::protobuf::internal::kEmptyString) {
    m_ = new ::std::string;
  }
  m_->assign(value);
}
inline void RsaPrivateKeyMessage::set_m(const char* value) {
  set_has_m();
  if (m_ == &::google::protobuf::internal::kEmptyString) {
    m_ = new ::std::string;
  }
  m_->assign(value);
}
inline void RsaPrivateKeyMessage::set_m(const void* value, size_t size) {
  set_has_m();
  if (m_ == &::google::protobuf::internal::kEmptyString) {
    m_ = new ::std::string;
  }
  m_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsaPrivateKeyMessage::mutable_m() {
  set_has_m();
  if (m_ == &::google::protobuf::internal::kEmptyString) {
    m_ = new ::std::string;
  }
  return m_;
}
inline ::std::string* RsaPrivateKeyMessage::release_m() {
  clear_has_m();
  if (m_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_;
    m_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsaPrivateKeyMessage::set_allocated_m(::std::string* m) {
  if (m_ != &::google::protobuf::internal::kEmptyString) {
    delete m_;
  }
  if (m) {
    set_has_m();
    m_ = m;
  } else {
    clear_has_m();
    m_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes e = 2;
inline bool RsaPrivateKeyMessage::has_e() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RsaPrivateKeyMessage::set_has_e() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RsaPrivateKeyMessage::clear_has_e() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RsaPrivateKeyMessage::clear_e() {
  if (e_ != &::google::protobuf::internal::kEmptyString) {
    e_->clear();
  }
  clear_has_e();
}
inline const ::std::string& RsaPrivateKeyMessage::e() const {
  return *e_;
}
inline void RsaPrivateKeyMessage::set_e(const ::std::string& value) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(value);
}
inline void RsaPrivateKeyMessage::set_e(const char* value) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(value);
}
inline void RsaPrivateKeyMessage::set_e(const void* value, size_t size) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsaPrivateKeyMessage::mutable_e() {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  return e_;
}
inline ::std::string* RsaPrivateKeyMessage::release_e() {
  clear_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e_;
    e_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsaPrivateKeyMessage::set_allocated_e(::std::string* e) {
  if (e_ != &::google::protobuf::internal::kEmptyString) {
    delete e_;
  }
  if (e) {
    set_has_e();
    e_ = e;
  } else {
    clear_has_e();
    e_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes d = 3;
inline bool RsaPrivateKeyMessage::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RsaPrivateKeyMessage::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RsaPrivateKeyMessage::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RsaPrivateKeyMessage::clear_d() {
  if (d_ != &::google::protobuf::internal::kEmptyString) {
    d_->clear();
  }
  clear_has_d();
}
inline const ::std::string& RsaPrivateKeyMessage::d() const {
  return *d_;
}
inline void RsaPrivateKeyMessage::set_d(const ::std::string& value) {
  set_has_d();
  if (d_ == &::google::protobuf::internal::kEmptyString) {
    d_ = new ::std::string;
  }
  d_->assign(value);
}
inline void RsaPrivateKeyMessage::set_d(const char* value) {
  set_has_d();
  if (d_ == &::google::protobuf::internal::kEmptyString) {
    d_ = new ::std::string;
  }
  d_->assign(value);
}
inline void RsaPrivateKeyMessage::set_d(const void* value, size_t size) {
  set_has_d();
  if (d_ == &::google::protobuf::internal::kEmptyString) {
    d_ = new ::std::string;
  }
  d_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsaPrivateKeyMessage::mutable_d() {
  set_has_d();
  if (d_ == &::google::protobuf::internal::kEmptyString) {
    d_ = new ::std::string;
  }
  return d_;
}
inline ::std::string* RsaPrivateKeyMessage::release_d() {
  clear_has_d();
  if (d_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = d_;
    d_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsaPrivateKeyMessage::set_allocated_d(::std::string* d) {
  if (d_ != &::google::protobuf::internal::kEmptyString) {
    delete d_;
  }
  if (d) {
    set_has_d();
    d_ = d;
  } else {
    clear_has_d();
    d_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes p = 4;
inline bool RsaPrivateKeyMessage::has_p() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RsaPrivateKeyMessage::set_has_p() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RsaPrivateKeyMessage::clear_has_p() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RsaPrivateKeyMessage::clear_p() {
  if (p_ != &::google::protobuf::internal::kEmptyString) {
    p_->clear();
  }
  clear_has_p();
}
inline const ::std::string& RsaPrivateKeyMessage::p() const {
  return *p_;
}
inline void RsaPrivateKeyMessage::set_p(const ::std::string& value) {
  set_has_p();
  if (p_ == &::google::protobuf::internal::kEmptyString) {
    p_ = new ::std::string;
  }
  p_->assign(value);
}
inline void RsaPrivateKeyMessage::set_p(const char* value) {
  set_has_p();
  if (p_ == &::google::protobuf::internal::kEmptyString) {
    p_ = new ::std::string;
  }
  p_->assign(value);
}
inline void RsaPrivateKeyMessage::set_p(const void* value, size_t size) {
  set_has_p();
  if (p_ == &::google::protobuf::internal::kEmptyString) {
    p_ = new ::std::string;
  }
  p_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsaPrivateKeyMessage::mutable_p() {
  set_has_p();
  if (p_ == &::google::protobuf::internal::kEmptyString) {
    p_ = new ::std::string;
  }
  return p_;
}
inline ::std::string* RsaPrivateKeyMessage::release_p() {
  clear_has_p();
  if (p_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = p_;
    p_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsaPrivateKeyMessage::set_allocated_p(::std::string* p) {
  if (p_ != &::google::protobuf::internal::kEmptyString) {
    delete p_;
  }
  if (p) {
    set_has_p();
    p_ = p;
  } else {
    clear_has_p();
    p_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes q = 5;
inline bool RsaPrivateKeyMessage::has_q() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RsaPrivateKeyMessage::set_has_q() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RsaPrivateKeyMessage::clear_has_q() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RsaPrivateKeyMessage::clear_q() {
  if (q_ != &::google::protobuf::internal::kEmptyString) {
    q_->clear();
  }
  clear_has_q();
}
inline const ::std::string& RsaPrivateKeyMessage::q() const {
  return *q_;
}
inline void RsaPrivateKeyMessage::set_q(const ::std::string& value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::kEmptyString) {
    q_ = new ::std::string;
  }
  q_->assign(value);
}
inline void RsaPrivateKeyMessage::set_q(const char* value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::kEmptyString) {
    q_ = new ::std::string;
  }
  q_->assign(value);
}
inline void RsaPrivateKeyMessage::set_q(const void* value, size_t size) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::kEmptyString) {
    q_ = new ::std::string;
  }
  q_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsaPrivateKeyMessage::mutable_q() {
  set_has_q();
  if (q_ == &::google::protobuf::internal::kEmptyString) {
    q_ = new ::std::string;
  }
  return q_;
}
inline ::std::string* RsaPrivateKeyMessage::release_q() {
  clear_has_q();
  if (q_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = q_;
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsaPrivateKeyMessage::set_allocated_q(::std::string* q) {
  if (q_ != &::google::protobuf::internal::kEmptyString) {
    delete q_;
  }
  if (q) {
    set_has_q();
    q_ = q;
  } else {
    clear_has_q();
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EcPrivateKeyMessage

// optional bytes der_blob = 1;
inline bool EcPrivateKeyMessage::has_der_blob() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EcPrivateKeyMessage::set_has_der_blob() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EcPrivateKeyMessage::clear_has_der_blob() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EcPrivateKeyMessage::clear_der_blob() {
  if (der_blob_ != &::google::protobuf::internal::kEmptyString) {
    der_blob_->clear();
  }
  clear_has_der_blob();
}
inline const ::std::string& EcPrivateKeyMessage::der_blob() const {
  return *der_blob_;
}
inline void EcPrivateKeyMessage::set_der_blob(const ::std::string& value) {
  set_has_der_blob();
  if (der_blob_ == &::google::protobuf::internal::kEmptyString) {
    der_blob_ = new ::std::string;
  }
  der_blob_->assign(value);
}
inline void EcPrivateKeyMessage::set_der_blob(const char* value) {
  set_has_der_blob();
  if (der_blob_ == &::google::protobuf::internal::kEmptyString) {
    der_blob_ = new ::std::string;
  }
  der_blob_->assign(value);
}
inline void EcPrivateKeyMessage::set_der_blob(const void* value, size_t size) {
  set_has_der_blob();
  if (der_blob_ == &::google::protobuf::internal::kEmptyString) {
    der_blob_ = new ::std::string;
  }
  der_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EcPrivateKeyMessage::mutable_der_blob() {
  set_has_der_blob();
  if (der_blob_ == &::google::protobuf::internal::kEmptyString) {
    der_blob_ = new ::std::string;
  }
  return der_blob_;
}
inline ::std::string* EcPrivateKeyMessage::release_der_blob() {
  clear_has_der_blob();
  if (der_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = der_blob_;
    der_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EcPrivateKeyMessage::set_allocated_der_blob(::std::string* der_blob) {
  if (der_blob_ != &::google::protobuf::internal::kEmptyString) {
    delete der_blob_;
  }
  if (der_blob) {
    set_has_der_blob();
    der_blob_ = der_blob;
  } else {
    clear_has_der_blob();
    der_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PrivateKeyMessage

// required string key_type = 1;
inline bool PrivateKeyMessage::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrivateKeyMessage::set_has_key_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrivateKeyMessage::clear_has_key_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrivateKeyMessage::clear_key_type() {
  if (key_type_ != &::google::protobuf::internal::kEmptyString) {
    key_type_->clear();
  }
  clear_has_key_type();
}
inline const ::std::string& PrivateKeyMessage::key_type() const {
  return *key_type_;
}
inline void PrivateKeyMessage::set_key_type(const ::std::string& value) {
  set_has_key_type();
  if (key_type_ == &::google::protobuf::internal::kEmptyString) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(value);
}
inline void PrivateKeyMessage::set_key_type(const char* value) {
  set_has_key_type();
  if (key_type_ == &::google::protobuf::internal::kEmptyString) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(value);
}
inline void PrivateKeyMessage::set_key_type(const char* value, size_t size) {
  set_has_key_type();
  if (key_type_ == &::google::protobuf::internal::kEmptyString) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateKeyMessage::mutable_key_type() {
  set_has_key_type();
  if (key_type_ == &::google::protobuf::internal::kEmptyString) {
    key_type_ = new ::std::string;
  }
  return key_type_;
}
inline ::std::string* PrivateKeyMessage::release_key_type() {
  clear_has_key_type();
  if (key_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_type_;
    key_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PrivateKeyMessage::set_allocated_key_type(::std::string* key_type) {
  if (key_type_ != &::google::protobuf::internal::kEmptyString) {
    delete key_type_;
  }
  if (key_type) {
    set_has_key_type();
    key_type_ = key_type;
  } else {
    clear_has_key_type();
    key_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .taosupport.RsaPrivateKeyMessage rsa_key = 2;
inline bool PrivateKeyMessage::has_rsa_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrivateKeyMessage::set_has_rsa_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrivateKeyMessage::clear_has_rsa_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrivateKeyMessage::clear_rsa_key() {
  if (rsa_key_ != NULL) rsa_key_->::taosupport::RsaPrivateKeyMessage::Clear();
  clear_has_rsa_key();
}
inline const ::taosupport::RsaPrivateKeyMessage& PrivateKeyMessage::rsa_key() const {
  return rsa_key_ != NULL ? *rsa_key_ : *default_instance_->rsa_key_;
}
inline ::taosupport::RsaPrivateKeyMessage* PrivateKeyMessage::mutable_rsa_key() {
  set_has_rsa_key();
  if (rsa_key_ == NULL) rsa_key_ = new ::taosupport::RsaPrivateKeyMessage;
  return rsa_key_;
}
inline ::taosupport::RsaPrivateKeyMessage* PrivateKeyMessage::release_rsa_key() {
  clear_has_rsa_key();
  ::taosupport::RsaPrivateKeyMessage* temp = rsa_key_;
  rsa_key_ = NULL;
  return temp;
}
inline void PrivateKeyMessage::set_allocated_rsa_key(::taosupport::RsaPrivateKeyMessage* rsa_key) {
  delete rsa_key_;
  rsa_key_ = rsa_key;
  if (rsa_key) {
    set_has_rsa_key();
  } else {
    clear_has_rsa_key();
  }
}

// optional .taosupport.EcPrivateKeyMessage ec_key = 3;
inline bool PrivateKeyMessage::has_ec_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrivateKeyMessage::set_has_ec_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrivateKeyMessage::clear_has_ec_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrivateKeyMessage::clear_ec_key() {
  if (ec_key_ != NULL) ec_key_->::taosupport::EcPrivateKeyMessage::Clear();
  clear_has_ec_key();
}
inline const ::taosupport::EcPrivateKeyMessage& PrivateKeyMessage::ec_key() const {
  return ec_key_ != NULL ? *ec_key_ : *default_instance_->ec_key_;
}
inline ::taosupport::EcPrivateKeyMessage* PrivateKeyMessage::mutable_ec_key() {
  set_has_ec_key();
  if (ec_key_ == NULL) ec_key_ = new ::taosupport::EcPrivateKeyMessage;
  return ec_key_;
}
inline ::taosupport::EcPrivateKeyMessage* PrivateKeyMessage::release_ec_key() {
  clear_has_ec_key();
  ::taosupport::EcPrivateKeyMessage* temp = ec_key_;
  ec_key_ = NULL;
  return temp;
}
inline void PrivateKeyMessage::set_allocated_ec_key(::taosupport::EcPrivateKeyMessage* ec_key) {
  delete ec_key_;
  ec_key_ = ec_key;
  if (ec_key) {
    set_has_ec_key();
  } else {
    clear_has_ec_key();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace taosupport

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taosupport::MessageType>() {
  return ::taosupport::MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_taosupport_2eproto__INCLUDED
