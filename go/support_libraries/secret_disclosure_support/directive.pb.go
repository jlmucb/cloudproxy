// Code generated by protoc-gen-go.
// source: directive.proto
// DO NOT EDIT!

package secret_disclosure

import proto "github.com/golang/protobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

// As of now, the only type supported is "secret_disclosure".
type DirectiveMessageDirectiveType int32

const (
	DirectiveMessage_SECRET_DISCLOSURE DirectiveMessageDirectiveType = 1
)

var DirectiveMessageDirectiveType_name = map[int32]string{
	1: "SECRET_DISCLOSURE",
}
var DirectiveMessageDirectiveType_value = map[string]int32{
	"SECRET_DISCLOSURE": 1,
}

func (x DirectiveMessageDirectiveType) Enum() *DirectiveMessageDirectiveType {
	p := new(DirectiveMessageDirectiveType)
	*p = x
	return p
}
func (x DirectiveMessageDirectiveType) String() string {
	return proto.EnumName(DirectiveMessageDirectiveType_name, int32(x))
}
func (x DirectiveMessageDirectiveType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *DirectiveMessageDirectiveType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DirectiveMessageDirectiveType_value, data, "DirectiveMessageDirectiveType")
	if err != nil {
		return err
	}
	*x = DirectiveMessageDirectiveType(value)
	return nil
}

type DirectiveMessage struct {
	Type *DirectiveMessageDirectiveType `protobuf:"varint,1,opt,name=type,enum=secret_disclosure.DirectiveMessageDirectiveType" json:"type,omitempty"`
	// A serialized statement. This is serialized using cloudproxy/tao/auth.Marshal().
	//
	// The statement corresponding to type "key_disclosure" must be of the form:
	// policy_key says program_name can read (secret_name, epoch).
	SerializedStatement []byte `protobuf:"bytes,2,opt,name=serialized_statement" json:"serialized_statement,omitempty"`
	// The signer's public key principal, encoded using clouddproxy/tao/auth.Marshal().
	Signer []byte `protobuf:"bytes,3,opt,name=signer" json:"signer,omitempty"`
	// Signature over the serialized statement.
	Signature []byte `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// Program certificate, to be used in case signer is a program key.
	Cert             []byte `protobuf:"bytes,5,opt,name=cert" json:"cert,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DirectiveMessage) Reset()         { *m = DirectiveMessage{} }
func (m *DirectiveMessage) String() string { return proto.CompactTextString(m) }
func (*DirectiveMessage) ProtoMessage()    {}

func (m *DirectiveMessage) GetType() DirectiveMessageDirectiveType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *DirectiveMessage) GetSerializedStatement() []byte {
	if m != nil {
		return m.SerializedStatement
	}
	return nil
}

func (m *DirectiveMessage) GetSigner() []byte {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *DirectiveMessage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DirectiveMessage) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func init() {
	proto.RegisterEnum("secret_disclosure.DirectiveMessageDirectiveType", DirectiveMessageDirectiveType_name, DirectiveMessageDirectiveType_value)
}
